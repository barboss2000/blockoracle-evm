<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BTC Prediction â€” Robinhood Chain</title>

<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Syne:wght@700;800&display=swap" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script src="https://s3.tradingview.com/tv.js"></script>

<style>
:root {
  --neon: #d5fd51;
  --neon-dim: rgba(213,253,81,0.12);
  --neon-dim2: rgba(213,253,81,0.06);
  --black: #0a0a0a;
  --surface: #111111;
  --surface2: #181818;
  --surface3: #202020;
  --border: #2a2a2a;
  --border-light: #333333;
  --text: #ffffff;
  --text-muted: #666666;
  --text-dim: #444444;
  --up: #4ade80;
  --down: #f87171;
  --up-dim: rgba(74,222,128,0.1);
  --down-dim: rgba(248,113,113,0.1);
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: #0d1a0a;
  color: var(--text);
  font-family: 'DM Mono', monospace;
  min-height: 100vh;
  overflow-x: hidden;
}

/* Graffiti background canvas */
#graffiti-bg {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
  opacity: 0.85;
}

.page { position: relative; z-index: 1; }

/* Header */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 32px;
  border-bottom: 1px solid var(--border);
  background: rgba(10,10,10,0.95);
  backdrop-filter: blur(10px);
  position: sticky;
  top: 0;
  z-index: 100;
}

.logo {
  display: flex;
  align-items: center;
  gap: 10px;
}

.logo-icon {
  width: 28px;
  height: 28px;
  background: var(--neon);
  clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
  display: flex;
  align-items: center;
  justify-content: center;
  animation: pulse-logo 3s ease-in-out infinite;
}

@keyframes pulse-logo {
  0%, 100% { box-shadow: 0 0 0 0 rgba(213,253,81,0.4); }
  50% { box-shadow: 0 0 20px 4px rgba(213,253,81,0.2); }
}

.logo-text {
  font-family: 'Syne', sans-serif;
  font-weight: 800;
  font-size: 16px;
  letter-spacing: -0.5px;
}

.logo-text span { color: var(--neon); }

.header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.chain-badge {
  font-size: 11px;
  color: var(--text-muted);
  border: 1px solid var(--border);
  padding: 4px 10px;
  border-radius: 4px;
  letter-spacing: 1px;
  text-transform: uppercase;
}

.btn-connect {
  background: var(--neon);
  color: var(--black);
  border: none;
  padding: 8px 18px;
  border-radius: 6px;
  font-family: 'DM Mono', monospace;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  letter-spacing: 0.5px;
  transition: all 0.2s;
}
.btn-connect:hover { background: #c5ed41; transform: translateY(-1px); }

.btn-faucet {
  background: transparent;
  color: var(--neon);
  border: 1px solid rgba(213,253,81,0.35);
  padding: 8px 16px;
  border-radius: 6px;
  font-family: 'DM Mono', monospace;
  font-size: 12px;
  cursor: pointer;
  letter-spacing: 0.5px;
  text-decoration: none;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 5px;
}
.btn-faucet:hover { background: var(--neon-dim); border-color: var(--neon); }
.btn-connect.connected {
  background: var(--surface2);
  color: var(--neon);
  border: 1px solid var(--border);
  cursor: default;
}
.btn-connect.connected:hover { transform: none; background: var(--surface2); }

/* Chart */
#tv_chart {
  width: 100%;
  border-bottom: 1px solid var(--border);
}

/* Main layout */
.main {
  max-width: 520px;
  margin: 0 auto;
  padding: 28px 20px 60px;
}

/* Stats panel */
.stats-panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  animation: fadeUp 0.4s ease both;
}

@keyframes fadeUp {
  from { opacity:0; transform:translateY(12px); }
  to   { opacity:1; transform:translateY(0); }
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 16px;
}

.stat-item {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px 14px;
}

.stat-label {
  font-size: 10px;
  color: var(--text-muted);
  letter-spacing: 1.5px;
  text-transform: uppercase;
  margin-bottom: 4px;
}

.stat-value {
  font-size: 16px;
  font-weight: 500;
  color: var(--text);
}

.stat-value.neon { color: var(--neon); }
.stat-value.up   { color: var(--up); }
.stat-value.down { color: var(--down); }

/* Round status row */
.round-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  margin-bottom: 16px;
}

.round-label { font-size: 11px; color: var(--text-muted); letter-spacing: 1px; text-transform: uppercase; }
.round-num { font-size: 14px; color: var(--text); }

.status-pill {
  font-size: 10px;
  font-weight: 500;
  padding: 3px 10px;
  border-radius: 20px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.status-active  { background: rgba(74,222,128,0.15); color: var(--up); border: 1px solid rgba(74,222,128,0.3); }
.status-ended   { background: rgba(248,113,113,0.12); color: var(--down); border: 1px solid rgba(248,113,113,0.3); }
.status-waiting { background: var(--neon-dim); color: var(--neon); border: 1px solid rgba(213,253,81,0.3); }

/* Timer */
.timer-block {
  text-align: center;
  padding: 16px;
  background: var(--neon-dim2);
  border: 1px solid rgba(213,253,81,0.15);
  border-radius: 8px;
  margin-bottom: 16px;
}

.timer-label { font-size: 10px; color: var(--text-muted); letter-spacing: 2px; text-transform: uppercase; margin-bottom: 4px; }
.timer-value { font-family: 'Syne', sans-serif; font-size: 36px; font-weight: 800; color: var(--neon); letter-spacing: -1px; }
.timer-value.ended { color: var(--down); font-size: 14px; font-weight: 500; font-family: 'DM Mono', monospace; letter-spacing: 0; }

/* Pool bar */
.pool-bar-wrap { margin-bottom: 16px; }
.pool-bar-labels {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  margin-bottom: 6px;
}
.pool-bar-labels .up-label { color: var(--up); }
.pool-bar-labels .down-label { color: var(--down); }
.pool-bar-track {
  height: 6px;
  background: var(--down-dim);
  border-radius: 3px;
  overflow: hidden;
  border: 1px solid var(--border);
}
.pool-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--up), #22c55e);
  border-radius: 3px;
  transition: width 0.6s ease;
}

/* Divider */
.divider { border: none; border-top: 1px solid var(--border); margin: 18px 0; }

/* Bet panel */
.bet-panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  animation: fadeUp 0.4s ease 0.1s both;
}

.bet-panel-title {
  font-size: 10px;
  color: var(--text-muted);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 16px;
}

.amount-input-wrap {
  position: relative;
  margin-bottom: 16px;
}

.amount-input {
  width: 100%;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 14px 50px 14px 16px;
  font-family: 'DM Mono', monospace;
  font-size: 20px;
  color: var(--text);
  outline: none;
  transition: border-color 0.2s;
}
.amount-input:focus { border-color: var(--neon); }
.amount-input::placeholder { color: var(--text-dim); }

.amount-suffix {
  position: absolute;
  right: 14px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--text-muted);
}

/* Duration buttons */
.dur-label {
  font-size: 10px;
  color: var(--text-muted);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 8px;
}

.dur-group {
  display: flex;
  gap: 6px;
  margin-bottom: 18px;
}

.dur-btn {
  flex: 1;
  padding: 8px 4px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-muted);
  font-family: 'DM Mono', monospace;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s;
  text-align: center;
}
.dur-btn:hover { border-color: var(--neon); color: var(--text); }
.dur-btn.active { background: var(--neon-dim); border-color: var(--neon); color: var(--neon); }

/* Bet buttons */
.bet-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }

.btn-up, .btn-down {
  padding: 16px;
  border: none;
  border-radius: 8px;
  font-family: 'Syne', sans-serif;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.btn-up {
  background: var(--up-dim);
  color: var(--up);
  border: 1px solid rgba(74,222,128,0.3);
}
.btn-up:hover:not(:disabled) {
  background: var(--up);
  color: var(--black);
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(74,222,128,0.25);
}
.btn-up:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }

.btn-down {
  background: var(--down-dim);
  color: var(--down);
  border: 1px solid rgba(248,113,113,0.3);
}
.btn-down:hover:not(:disabled) {
  background: var(--down);
  color: var(--black);
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(248,113,113,0.25);
}
.btn-down:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }

/* Hint */
#betHint {
  text-align: center;
  font-size: 11px;
  min-height: 18px;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}

/* Claim button */
.btn-claim {
  width: 100%;
  padding: 13px;
  background: var(--neon-dim);
  border: 1px solid rgba(213,253,81,0.3);
  border-radius: 8px;
  color: var(--neon);
  font-family: 'DM Mono', monospace;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
  letter-spacing: 0.5px;
}
.btn-claim:hover:not(:disabled) {
  background: var(--neon);
  color: var(--black);
  font-weight: 600;
}
.btn-claim:disabled { opacity: 0.3; cursor: not-allowed; }

/* Active bets */

/* Owner panel */
.owner-panel {
  background: var(--surface);
  border: 1px solid rgba(213,253,81,0.2);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  animation: fadeUp 0.4s ease 0.3s both;
}
.owner-panel-title {
  font-size: 10px;
  color: var(--neon);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 14px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.owner-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.owner-input {
  flex: 1;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 9px 12px;
  font-family: 'DM Mono', monospace;
  font-size: 13px;
  color: var(--text);
  outline: none;
}
.owner-input:focus { border-color: var(--neon); }
.btn-owner {
  padding: 9px 14px;
  border: none;
  border-radius: 6px;
  font-family: 'DM Mono', monospace;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
}
.btn-deposit  { background: var(--neon-dim); color: var(--neon); border: 1px solid rgba(213,253,81,0.3); }
.btn-deposit:hover  { background: var(--neon); color: var(--black); }
.btn-withdraw { background: var(--up-dim); color: var(--up); border: 1px solid rgba(74,222,128,0.3); }
.btn-withdraw:hover { background: var(--up); color: var(--black); }
.btn-withdraw-all { background: var(--down-dim); color: var(--down); border: 1px solid rgba(248,113,113,0.3); }
.btn-withdraw-all:hover { background: var(--down); color: var(--black); }
.owner-stats {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 8px;
  margin-bottom: 14px;
}
.owner-stat {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 10px;
  text-align: center;
}
.owner-stat-label { font-size: 9px; color: var(--text-muted); letter-spacing: 1px; text-transform: uppercase; margin-bottom: 3px; }
.owner-stat-val   { font-size: 13px; color: var(--neon); }

.bets-section {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px 20px;
  animation: fadeUp 0.4s ease 0.2s both;
}

.bets-title {
  font-size: 10px;
  color: var(--text-muted);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 12px;
}

.bet-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 12px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  margin-bottom: 6px;
  transition: border-color 0.2s;
}
.bet-item:hover { border-color: var(--border-light); }

.bet-dir-badge {
  font-size: 10px;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 4px;
  letter-spacing: 1px;
  min-width: 44px;
  text-align: center;
}
.bet-dir-badge.up   { background: var(--up-dim); color: var(--up); border: 1px solid rgba(74,222,128,0.2); }
.bet-dir-badge.down { background: var(--down-dim); color: var(--down); border: 1px solid rgba(248,113,113,0.2); }

.bet-info { flex: 1; }
.bet-amount { font-size: 13px; color: var(--text); }
.bet-meta { font-size: 10px; color: var(--text-muted); margin-top: 2px; letter-spacing: 0.5px; }

.bet-timer { font-family: 'Syne', sans-serif; font-size: 18px; font-weight: 700; color: var(--neon); min-width: 52px; text-align: right; }
.bet-timer.expired { font-family: 'DM Mono', monospace; font-size: 10px; font-weight: 400; color: var(--down); letter-spacing: 1px; }

/* Settled result banner */
.result-banner {
  display: none;
  padding: 14px 18px;
  border-radius: 8px;
  margin-bottom: 16px;
  text-align: center;
  font-family: 'Syne', sans-serif;
  font-weight: 700;
  font-size: 15px;
  letter-spacing: 0.5px;
}
.result-banner.up-won { background: var(--up-dim); border: 1px solid rgba(74,222,128,0.3); color: var(--up); }
.result-banner.down-won { background: var(--down-dim); border: 1px solid rgba(248,113,113,0.3); color: var(--down); }
.result-banner.show { display: block; }

</style>
</head>
<body>
<canvas id="graffiti-bg"></canvas>
<div class="page">

  <!-- Header -->
  <header class="header">
    <div class="logo">
      <div class="logo-icon"></div>
      <div class="logo-text">BLOCK<span>ORACLE</span></div>
    </div>
    <div class="header-right">
      <a href="https://faucet.testnet.chain.robinhood.com/?error=undefined&address=0x6d4D522f22681b76483BF327ff7Bb6748a68Da5c&step=auth" target="_blank" class="btn-faucet">ðŸ’§ Faucet</a>
      <div class="chain-badge">Robinhood Chain Â· 46630</div>
      <button class="btn-connect" id="btnConnect" onclick="connect()">Connect Wallet</button>
    </div>
  </header>

  <!-- Chart -->
  <div id="tv_chart"></div>

  <!-- Main -->
  <div class="main">

    <!-- Stats -->
    <div class="stats-panel">
      <!-- Round row -->
      <div class="round-row">
        <div>
          <div class="round-label">Round</div>
          <div class="round-num" id="round">â€”</div>
        </div>
        <div style="text-align:center;">
          <div class="round-label">Lock Price</div>
          <div class="round-num" id="lockPrice">â€”</div>
        </div>
        <span id="roundStatus" class="status-pill status-waiting">â€”</span>
      </div>

      <!-- Pool bar -->
      <div class="pool-bar-wrap">
        <div class="pool-bar-labels">
          <span class="up-label">â–² UP &nbsp;<span id="upPool">0.0000 ETH</span></span>
          <span style="color:var(--text-muted)" id="probUp">0%</span>
          <span class="down-label"><span id="downPool">0.0000 ETH</span>&nbsp; DOWN â–¼</span>
        </div>
        <div class="pool-bar-track">
          <div class="pool-bar-fill" id="poolBar" style="width:50%"></div>
        </div>
      </div>

      <!-- Stats grid -->
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-label">Wallet</div>
          <div class="stat-value" id="wallet" style="font-size:13px;">Not connected</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Round ends in</div>
          <div class="stat-value neon" id="timeLeftSmall">â€”</div>
        </div>
      </div>

      <!-- Result banner -->
      <div class="result-banner" id="resultBanner"></div>
    </div>

    <!-- Bet panel -->
    <div class="bet-panel">
      <div class="bet-panel-title">Place your bet</div>

      <div class="amount-input-wrap">
        <input class="amount-input" id="amount" type="number" placeholder="0.0001" step="0.0001" min="0.0001"/>
        <span class="amount-suffix">ETH</span>
      </div>

      <div class="dur-label">Duration</div>
      <div class="dur-group">
        <button class="dur-btn active" onclick="selectDuration(1, this)">1m</button>
        <button class="dur-btn" onclick="selectDuration(2, this)">2m</button>
        <button class="dur-btn" onclick="selectDuration(3, this)">3m</button>
        <button class="dur-btn" onclick="selectDuration(4, this)">4m</button>
        <button class="dur-btn" onclick="selectDuration(5, this)">5m</button>
      </div>

      <div class="bet-buttons">
        <button class="btn-up" id="btnUp" onclick="betUp()" disabled>â–² &nbsp;UP</button>
        <button class="btn-down" id="btnDown" onclick="betDown()" disabled>â–¼ &nbsp;DOWN</button>
      </div>

      <div id="betHint"></div>

      <button class="btn-claim" id="btnClaim" onclick="claim()" disabled>â˜… &nbsp;Claim Winnings</button>
    </div>

    <!-- Active bets -->

    <!-- Owner panel (hidden, shown only for owner) -->
    <div class="owner-panel" id="ownerPanel" style="display:none;">
      <div class="owner-panel-title">â¬¡ &nbsp;Owner Controls</div>

      <!-- Balance info -->
      <div class="owner-stats">
        <div class="owner-stat">
          <div class="owner-stat-label">Contract</div>
          <div class="owner-stat-val" id="ownerBalContract">â€”</div>
        </div>
        <div class="owner-stat">
          <div class="owner-stat-label">My Profit</div>
          <div class="owner-stat-val" id="ownerBalProfit">â€”</div>
        </div>
        <div class="owner-stat">
          <div class="owner-stat-label">Liquidity</div>
          <div class="owner-stat-val" id="ownerBalLiquidity">â€”</div>
        </div>
      </div>

      <!-- Deposit liquidity -->
      <div class="owner-row">
        <input class="owner-input" id="depositAmount" type="number" placeholder="ETH amount" step="0.001" min="0.001"/>
        <button class="btn-owner btn-deposit" onclick="ownerDeposit()">â¬† Deposit</button>
      </div>

      <!-- Withdraw profit -->
      <div class="owner-row">
        <input class="owner-input" id="withdrawAmount" type="number" placeholder="ETH (0 = all profit)" step="0.001" min="0"/>
        <button class="btn-owner btn-withdraw" onclick="ownerWithdraw()">â¬‡ Withdraw Profit</button>
        <button class="btn-owner btn-withdraw-all" onclick="ownerWithdrawAll()">All</button>
      </div>
    </div>

    <div class="bets-section" id="betsSection" style="display:none;">
      <div class="bets-title">My Active Bets</div>
      <div id="betsList"></div>
    </div>

  </div>
</div>

<script>

const CONTRACT_ADDRESS = "0xE1D77C412785eD34B991f871fFc51f6458deB997";
const CHAIN_ID = 46630;

const abi = [
  "function betUp() payable",
  "function betDown() payable",
  "function claim(uint256,address)",
  "function startRound(uint256,uint256)",
  "function settleRound(uint256)",
  "function currentRound() view returns(uint256)",
  "function rounds(uint256) view returns(uint256,uint256,uint256,uint256,uint256,uint256,bool,bool)",
  "function pools(uint256,address) view returns(uint256,uint256)",
  "function owner() view returns(address)",
  "function depositLiquidity() payable",
  "function withdrawProfit(uint256)",
  "function withdrawLiquidity(uint256)",
  "function balanceInfo() view returns(uint256,uint256,uint256)",
  "function previewPayout(uint256,address) view returns(uint256)",
  "function ownerProfit() view returns(uint256)",
  "function liquidityPool() view returns(uint256)"
];

let provider, signer, contract, user, contractOwner;
let roundTimerInterval = null;
let selectedDuration = 1;
let activeBets = [];
let betsRenderInterval = null;
let isRoundActive = false;
let alreadyBetThisRound = false;

function selectDuration(min, btn) {
  selectedDuration = min;
  document.querySelectorAll('.dur-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}

function updateBetButtons() {
  const connected = !!user && !!contract;
  const canBet = connected && !alreadyBetThisRound;
  document.getElementById("btnUp").disabled = !canBet;
  document.getElementById("btnDown").disabled = !canBet;
  const hint = document.getElementById("betHint");
  if (connected && alreadyBetThisRound) {
    hint.innerText = "âœ“ Already bet this round";
    hint.style.color = "var(--up)";
  } else {
    hint.innerText = "";
  }
}

function addActiveBet(direction, amount, durationMin, roundId) {
  const endTime = Math.floor(Date.now() / 1000) + durationMin * 60;
  activeBets.push({ direction, amount, endTime, roundId: roundId.toString(), durationMin });
  renderBets();
  if (!betsRenderInterval) betsRenderInterval = setInterval(renderBets, 1000);
}

function renderBets() {
  const list = document.getElementById('betsList');
  const section = document.getElementById('betsSection');
  if (activeBets.length === 0) { section.style.display = 'none'; return; }
  section.style.display = 'block';
  const now = Math.floor(Date.now() / 1000);
  list.innerHTML = activeBets.map(bet => {
    const left = bet.endTime - now;
    const timerHtml = left > 0
      ? `<div class="bet-timer">${formatTime(left)}</div>`
      : `<div class="bet-timer expired">AWAITING</div>`;
    const dirClass = bet.direction === 'UP' ? 'up' : 'down';
    return `<div class="bet-item">
      <span class="bet-dir-badge ${dirClass}">${bet.direction}</span>
      <div class="bet-info">
        <div class="bet-amount">${parseFloat(bet.amount).toFixed(4)} ETH</div>
        <div class="bet-meta">Round #${bet.roundId} Â· ${bet.durationMin}m</div>
      </div>
      ${timerHtml}
    </div>`;
  }).join('');
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return m > 0 ? `${m}:${s.toString().padStart(2,'0')}` : `${s}s`;
}

async function connect() {
  if (!window.ethereum) { alert("MetaMask not found!"); return; }
  try {
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    const network = await provider.getNetwork();
    if (network.chainId !== CHAIN_ID) {
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x' + CHAIN_ID.toString(16) }]
        });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      } catch(e) {
        alert("Switch to Robinhood Chain Testnet (ChainID: 46630)");
        return;
      }
    }
    signer = provider.getSigner();
    user = await signer.getAddress();
    contract = new ethers.Contract(CONTRACT_ADDRESS, abi, signer);
    contractOwner = await contract.owner();

    document.getElementById("wallet").innerText = user.slice(0,6) + "..." + user.slice(-4);
    const btn = document.getElementById("btnConnect");
    btn.innerText = user.slice(0,6) + "..." + user.slice(-4);
    btn.classList.add("connected");
    btn.onclick = null;

    document.getElementById("btnClaim").disabled = false;
    updateBetButtons();
    await loadData();
    setInterval(loadData, 10000);
  } catch(e) {
    alert("Connection error: " + e.message);
  }
}

async function loadData() {
  if (!contract) return;
  try {
    const roundId = await contract.currentRound();
    document.getElementById("round").innerText = "#" + roundId.toString();

    const banner = document.getElementById("resultBanner");

    if (roundId.toNumber() === 0) {
      isRoundActive = false;
      alreadyBetThisRound = false;
      updateBetButtons();
      setStatus("No rounds yet", "waiting");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      document.getElementById("lockPrice").innerText = "â€”";
      banner.className = "result-banner";
      return;
    }

    const pool = await contract.pools(roundId, ethers.constants.AddressZero);
    const up = parseFloat(ethers.utils.formatEther(pool[0]));
    const down = parseFloat(ethers.utils.formatEther(pool[1]));
    document.getElementById("upPool").innerText = up.toFixed(4) + " ETH";
    document.getElementById("downPool").innerText = down.toFixed(4) + " ETH";
    const total = up + down;
    const prob = total > 0 ? (up / total * 100).toFixed(1) : 50;
    document.getElementById("probUp").innerText = prob + "%";
    document.getElementById("poolBar").style.width = prob + "%";

    const round = await contract.rounds(roundId);
    const endTime = round[1].toNumber();
    const lockPriceRaw = round[2].toNumber();
    const settled = round[6];

    document.getElementById("lockPrice").innerText = lockPriceRaw > 0 ? "$" + lockPriceRaw.toLocaleString() : "â€”";

    const now = Math.floor(Date.now() / 1000);

    if (settled) {
      isRoundActive = false;
      alreadyBetThisRound = false;
      const upWon = round[7];
      const closePrice = round[3].toNumber();
      setStatus("Settled", "waiting");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      if (roundTimerInterval) { clearInterval(roundTimerInterval); roundTimerInterval = null; }
      banner.className = "result-banner show " + (upWon ? "up-won" : "down-won");
      banner.innerHTML = upWon
        ? `â–² UP WON &nbsp;Â·&nbsp; Close $${closePrice.toLocaleString()}`
        : `â–¼ DOWN WON &nbsp;Â·&nbsp; Close $${closePrice.toLocaleString()}`;
    } else if (now >= endTime) {
      isRoundActive = false;
      alreadyBetThisRound = false;
      setStatus("Settling...", "ended");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      if (roundTimerInterval) { clearInterval(roundTimerInterval); roundTimerInterval = null; }
      banner.className = "result-banner";
      await autoSettle();
    } else {
      isRoundActive = true;
      setStatus("Active", "active");
      startRoundTimer(endTime);
      banner.className = "result-banner";
      if (user) {
        const userBet = await contract.pools(roundId, user);
        alreadyBetThisRound = userBet[0].gt(0) || userBet[1].gt(0);
      }
    }

    updateBetButtons();
    await loadOwnerStats();
  } catch(e) {
    console.error("loadData error:", e);
  }
}

function setStatus(text, type) {
  const el = document.getElementById("roundStatus");
  el.innerText = text;
  el.className = "status-pill status-" + type;
}

function startRoundTimer(endTime) {
  if (roundTimerInterval) clearInterval(roundTimerInterval);
  roundTimerInterval = setInterval(async () => {
    const now = Math.floor(Date.now() / 1000);
    const left = endTime - now;
    if (left > 0) {
      document.getElementById("timeLeftSmall").innerText = formatTime(left);
    } else {
      isRoundActive = false;
      alreadyBetThisRound = false;
      updateBetButtons();
      setStatus("Settling...", "ended");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      clearInterval(roundTimerInterval);
      roundTimerInterval = null;
      await autoSettle();
    }
  }, 1000);
}

async function autoSettle() {
  if (!contract || !user || !contractOwner) return;
  if (user.toLowerCase() !== contractOwner.toLowerCase()) {
    setTimeout(loadData, 5000);
    return;
  }
  try {
    let closePrice = 0;
    try {
      closePrice = await fetchBTCPrice();
    } catch(e) {
      console.error("Price fetch failed, retrying in 5s...");
      setTimeout(autoSettle, 5000);
      return;
    }
    const tx = await contract.settleRound(closePrice);
    await tx.wait();
    await loadData();
  } catch(e) {
    console.error("Auto-settle failed:", e.reason || e.message);
    setTimeout(autoSettle, 10000);
  }
}

// Fetch BTC price with multiple fallback sources
async function fetchBTCPrice() {
  const sources = [
    async () => {
      const r = await fetch("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT");
      const d = await r.json();
      return Math.round(parseFloat(d.price));
    },
    async () => {
      const r = await fetch("https://api.coinbase.com/v2/prices/BTC-USD/spot");
      const d = await r.json();
      return Math.round(parseFloat(d.data.amount));
    },
    async () => {
      const r = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd");
      const d = await r.json();
      return Math.round(d.bitcoin.usd);
    }
  ];

  for (const source of sources) {
    try {
      const price = await source();
      if (price > 1000) return price; // sanity check
    } catch(e) {
      console.warn("Price source failed, trying next...", e.message);
    }
  }
  throw new Error("All price sources failed");
}

async function autoStartRound() {
  try {
    const lockPrice = await fetchBTCPrice();
    const tx = await contract.startRound(selectedDuration, lockPrice);
    await tx.wait();
    await loadData();
  } catch(e) {
    alert("Could not start round: " + (e.reason || e.message));
  }
}

async function betUp() {
  if (!checkConnected()) return;
  const amount = document.getElementById("amount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter a valid amount"); return; }
  try {
    document.getElementById("btnUp").disabled = true;
    document.getElementById("btnDown").disabled = true;
    if (!isRoundActive) {
      await autoStartRound();
      if (!isRoundActive) return;
    }
    const roundId = await contract.currentRound();
    const tx = await contract.betUp({ value: ethers.utils.parseEther(amount) });
    await tx.wait();
    addActiveBet('UP', amount, selectedDuration, roundId);
    await loadData();
  } catch(e) {
    alert("Bet UP failed: " + (e.reason || e.message));
  } finally {
    updateBetButtons();
  }
}

async function betDown() {
  if (!checkConnected()) return;
  const amount = document.getElementById("amount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter a valid amount"); return; }
  try {
    document.getElementById("btnDown").disabled = true;
    document.getElementById("btnUp").disabled = true;
    if (!isRoundActive) {
      await autoStartRound();
      if (!isRoundActive) return;
    }
    const roundId = await contract.currentRound();
    const tx = await contract.betDown({ value: ethers.utils.parseEther(amount) });
    await tx.wait();
    addActiveBet('DOWN', amount, selectedDuration, roundId);
    await loadData();
  } catch(e) {
    alert("Bet DOWN failed: " + (e.reason || e.message));
  } finally {
    updateBetButtons();
  }
}

async function claim() {
  if (!checkConnected()) return;
  try {
    const roundId = await contract.currentRound();
    const prevRound = roundId.sub(1);
    const tx = await contract.claim(prevRound, user);
    await tx.wait();
    activeBets = activeBets.filter(b => b.endTime > Math.floor(Date.now() / 1000));
    renderBets();
    alert("Claimed!");
  } catch(e) {
    alert("Claim failed: " + (e.reason || e.message));
  }
}


// â”€â”€â”€ Owner panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadOwnerStats() {
  if (!contract || !user || user.toLowerCase() !== contractOwner.toLowerCase()) return;
  try {
    const info = await contract.balanceInfo();
    const fmt = (v) => parseFloat(ethers.utils.formatEther(v)).toFixed(4) + " ETH";
    document.getElementById("ownerBalContract").innerText  = fmt(info[0]);
    document.getElementById("ownerBalProfit").innerText    = fmt(info[1]);
    document.getElementById("ownerBalLiquidity").innerText = fmt(info[2]);
  } catch(e) { console.error("loadOwnerStats:", e); }
}

async function ownerDeposit() {
  const amount = document.getElementById("depositAmount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter ETH amount to deposit"); return; }
  try {
    const tx = await contract.depositLiquidity({ value: ethers.utils.parseEther(amount) });
    await tx.wait();
    document.getElementById("depositAmount").value = "";
    await loadOwnerStats();
    alert("Deposited " + amount + " ETH as liquidity âœ“");
  } catch(e) { alert("Deposit failed: " + (e.reason || e.message)); }
}

async function ownerWithdraw() {
  const input = document.getElementById("withdrawAmount").value;
  const amount = (!input || parseFloat(input) === 0) ? 0 : ethers.utils.parseEther(input);
  try {
    const tx = await contract.withdrawProfit(amount);
    await tx.wait();
    document.getElementById("withdrawAmount").value = "";
    await loadOwnerStats();
    alert("Profit withdrawn âœ“");
  } catch(e) { alert("Withdraw failed: " + (e.reason || e.message)); }
}

async function ownerWithdrawAll() {
  try {
    const tx = await contract.withdrawProfit(0); // 0 = withdraw all
    await tx.wait();
    await loadOwnerStats();
    alert("All profit withdrawn âœ“");
  } catch(e) { alert("Withdraw failed: " + (e.reason || e.message)); }
}

function checkConnected() {
  if (!user || !contract) { alert("Please connect your wallet first"); return false; }
  return true;
}

new TradingView.widget({
  "container_id": "tv_chart",
  "symbol": "BINANCE:BTCUSDT",
  "interval": "1",
  "theme": "dark",
  "width": "100%",
  "height": "380"
});


// â”€â”€â”€ Graffiti background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function() {
  const canvas = document.getElementById('graffiti-bg');
  const ctx = canvas.getContext('2d');
  const NEON = '#d5fd51';
  const NEON2 = '#b8e530';
  const WHITE = 'rgba(255,255,255,0.07)';
  const DIM = 'rgba(213,253,81,0.08)';

  function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
  }

  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function rand(min, max) { return Math.random() * (max - min) + min; }

  // Seeded random so it's consistent per session
  let seed = 42;
  function srnd() {
    seed = (seed * 16807 + 0) % 2147483647;
    return (seed - 1) / 2147483646;
  }
  function srandInt(min, max) { return Math.floor(srnd() * (max - min + 1)) + min; }
  function srand(min, max) { return srnd() * (max - min) + min; }

  function drawSprayPaint(ctx, x, y, radius, color, density = 60) {
    ctx.save();
    for (let i = 0; i < density; i++) {
      const angle = srnd() * Math.PI * 2;
      const r = Math.pow(srnd(), 0.5) * radius;
      const px = x + Math.cos(angle) * r;
      const py = y + Math.sin(angle) * r;
      const alpha = srand(0.02, 0.18);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(px, py, srand(0.5, 2.5), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawGraffitiLetter(ctx, x, y, letter, size, color, angle = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);

    // Outline / drip effect
    ctx.font = `900 ${size}px 'Syne', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Spray halo
    drawSprayPaint(ctx, 0, 0, size * 0.7, color, 80);

    // Shadow layers for depth
    ctx.shadowColor = color;
    ctx.shadowBlur = size * 0.3;
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = color;
    ctx.fillText(letter, 3, 6);

    // Outline stroke
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = color;
    ctx.lineWidth = size * 0.08;
    ctx.lineJoin = 'round';
    ctx.strokeText(letter, 0, 0);

    // Fill
    ctx.globalAlpha = 0.09;
    ctx.fillStyle = color;
    ctx.fillText(letter, 0, 0);

    // Drip
    const dripCount = srandInt(1, 3);
    for (let d = 0; d < dripCount; d++) {
      const dx = srand(-size * 0.3, size * 0.3);
      const dripLen = srand(size * 0.2, size * 0.9);
      const dripW = srand(2, 6);
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = color;
      ctx.lineWidth = dripW;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(dx, size * 0.4);
      ctx.bezierCurveTo(
        dx + srand(-8, 8), size * 0.5 + dripLen * 0.3,
        dx + srand(-8, 8), size * 0.5 + dripLen * 0.7,
        dx + srand(-4, 4), size * 0.4 + dripLen
      );
      ctx.stroke();
      // Drip end blob
      ctx.globalAlpha = 0.1;
      ctx.beginPath();
      ctx.arc(dx + srand(-4,4), size * 0.4 + dripLen, dripW * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }

    ctx.restore();
  }

  function drawTag(ctx, x, y, text, size, color, skew = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.transform(1, 0, skew, 1, 0, 0);

    const letters = text.split('');
    let ox = 0;
    for (const l of letters) {
      const angle = srand(-0.15, 0.15);
      const vertJitter = srand(-size * 0.15, size * 0.15);
      drawGraffitiLetter(ctx, ox, vertJitter, l, size, color, angle);
      ox += size * srand(0.55, 0.72);
    }
    ctx.restore();
  }

  function drawLine(ctx, x1, y1, x2, y2, color, width, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.lineCap = 'round';
    ctx.shadowColor = color;
    ctx.shadowBlur = width * 3;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  function drawArrow(ctx, x, y, size, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(srand(-0.3, 0.3));
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = color;
    ctx.lineWidth = size * 0.08;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    // Arrow up
    ctx.moveTo(0, size * 0.5);
    ctx.lineTo(0, -size * 0.5);
    ctx.moveTo(-size * 0.3, -size * 0.2);
    ctx.lineTo(0, -size * 0.5);
    ctx.lineTo(size * 0.3, -size * 0.2);
    ctx.stroke();
    ctx.restore();
  }

  function drawHexagon(ctx, x, y, r, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(srand(0, Math.PI));
    ctx.globalAlpha = srand(0.04, 0.1);
    ctx.strokeStyle = color;
    ctx.lineWidth = srand(1, 4);
    ctx.shadowColor = color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i;
      const px = Math.cos(angle) * r;
      const py = Math.sin(angle) * r;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  function draw() {
    const W = canvas.width;
    const H = canvas.height;
    seed = 42; // reset seed for consistent render

    ctx.clearRect(0, 0, W, H);

    // â”€â”€ Base: deep dark gradient (not pure black) â”€â”€
    const bgGrad = ctx.createLinearGradient(0, 0, W, H);
    bgGrad.addColorStop(0,   '#0d1a0a');
    bgGrad.addColorStop(0.3, '#0a0f1a');
    bgGrad.addColorStop(0.6, '#130d1f');
    bgGrad.addColorStop(1,   '#0a1410');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // â”€â”€ Ink splat blobs â€” big color explosions â”€â”€
    const blobs = [
      { x: W*0.08,  y: H*0.15, r: W*0.22, c: 'rgba(213,253,81,',  a: 0.13 },
      { x: W*0.85,  y: H*0.75, r: W*0.28, c: 'rgba(213,253,81,',  a: 0.10 },
      { x: W*0.5,   y: H*0.5,  r: W*0.35, c: 'rgba(74,222,128,',  a: 0.07 },
      { x: W*0.9,   y: H*0.1,  r: W*0.18, c: 'rgba(248,113,113,', a: 0.10 },
      { x: W*0.1,   y: H*0.85, r: W*0.20, c: 'rgba(248,113,113,', a: 0.08 },
      { x: W*0.55,  y: H*0.2,  r: W*0.15, c: 'rgba(184,229,48,',  a: 0.09 },
      { x: W*0.25,  y: H*0.55, r: W*0.12, c: 'rgba(213,253,81,',  a: 0.08 },
      { x: W*0.75,  y: H*0.45, r: W*0.16, c: 'rgba(74,222,128,',  a: 0.08 },
    ];

    for (const b of blobs) {
      // Radial splat
      const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
      g.addColorStop(0,   b.c + (b.a * 2.5) + ')');
      g.addColorStop(0.4, b.c + b.a + ')');
      g.addColorStop(0.75, b.c + (b.a * 0.3) + ')');
      g.addColorStop(1,   b.c + '0)');
      ctx.globalAlpha = 1;
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();

      // Splatter droplets around blob
      const color = b.c + (b.a * 3) + ')';
      for (let s = 0; s < 18; s++) {
        const angle = srnd() * Math.PI * 2;
        const dist  = srand(b.r * 0.5, b.r * 1.6);
        const sx = b.x + Math.cos(angle) * dist;
        const sy = b.y + Math.sin(angle) * dist;
        const sr2 = srand(2, b.r * 0.12);
        ctx.globalAlpha = srand(0.05, 0.18);
        ctx.fillStyle = b.c + (b.a * 4) + ')';
        ctx.beginPath();
        // Elongated splat drop
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(angle + Math.PI/2);
        ctx.ellipse(0, 0, sr2 * 0.5, sr2, 0, 0, Math.PI * 2);
        ctx.restore();
        ctx.fill();
      }
    }

    // â”€â”€ Spray strokes â€” wide brush marks â”€â”€
    const strokes = [
      { x1: W*0.0,  y1: H*0.3,  x2: W*0.4,  y2: H*0.15, c: NEON,            w: 80 },
      { x1: W*0.6,  y1: H*0.85, x2: W*1.0,  y2: H*0.65, c: NEON2,           w: 60 },
      { x1: W*0.2,  y1: H*0.9,  x2: W*0.7,  y2: H*0.95, c: '#4ade80',       w: 50 },
      { x1: W*0.7,  y1: H*0.0,  x2: W*0.95, y2: H*0.35, c: '#f87171',       w: 55 },
      { x1: W*0.0,  y1: H*0.65, x2: W*0.25, y2: H*0.5,  c: NEON,            w: 40 },
    ];

    for (const s of strokes) {
      const sg = ctx.createLinearGradient(s.x1, s.y1, s.x2, s.y2);
      sg.addColorStop(0,   s.c + '00');
      sg.addColorStop(0.3, s.c + '22');
      sg.addColorStop(0.5, s.c + '18');
      sg.addColorStop(1,   s.c + '00');
      ctx.globalAlpha = 1;
      ctx.strokeStyle = sg;
      ctx.lineWidth = s.w;
      ctx.lineCap = 'round';
      ctx.shadowColor = s.c;
      ctx.shadowBlur = s.w * 0.8;
      ctx.beginPath();
      ctx.moveTo(s.x1, s.y1);
      const mx = (s.x1 + s.x2) / 2 + srand(-W*0.1, W*0.1);
      const my = (s.y1 + s.y2) / 2 + srand(-H*0.1, H*0.1);
      ctx.quadraticCurveTo(mx, my, s.x2, s.y2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // â”€â”€ Concrete texture: noise â”€â”€
    for (let i = 0; i < 4000; i++) {
      ctx.globalAlpha = srand(0.01, 0.05);
      ctx.fillStyle = srnd() > 0.6 ? '#ffffff' : (srnd() > 0.5 ? NEON : '#333');
      const px = srnd() * W, py = srnd() * H;
      ctx.fillRect(px, py, srand(0.5, 2), srand(0.5, 2));
    }

    // Big background tags - words scattered
    const words = ['BLOCKORACLE', 'UP', 'DOWN', 'BTC', 'PREDICT', 'WIN', 'CHAIN', '0x'];
    const colors = [NEON, NEON2, 'rgba(255,255,255,0.6)', NEON];

    // Large background word
    drawTag(ctx, W * 0.02, H * 0.18, 'BLOCKORACLE', Math.min(W * 0.075, 90), NEON, -0.05);
    drawTag(ctx, W * 0.55, H * 0.72, 'ROBINHOOD', Math.min(W * 0.065, 80), NEON2, 0.04);
    drawTag(ctx, W * 0.05, H * 0.82, 'BTC', Math.min(W * 0.1, 120), NEON, -0.08);
    drawTag(ctx, W * 0.6, H * 0.12, 'PREDICT', Math.min(W * 0.055, 70), 'rgba(255,255,255,0.5)', 0.06);
    drawTag(ctx, W * 0.3, H * 0.45, 'WIN', Math.min(W * 0.12, 140), NEON2, -0.03);
    drawTag(ctx, W * 0.7, H * 0.38, '0xCHAIN', Math.min(W * 0.045, 55), NEON, 0.03);
    drawTag(ctx, W * 0.15, H * 0.6, 'UP', Math.min(W * 0.09, 110), NEON, 0.05);
    drawTag(ctx, W * 0.75, H * 0.6, 'DOWN', Math.min(W * 0.07, 85), '#f87171', -0.04);

    // Hexagons (blockchain motif)
    for (let i = 0; i < 18; i++) {
      drawHexagon(ctx, srnd() * W, srnd() * H, srand(20, 90), i % 3 === 0 ? NEON : NEON2);
    }

    // Arrows (UP / DOWN arrows)
    for (let i = 0; i < 12; i++) {
      drawArrow(ctx, srnd() * W, srnd() * H, srand(30, 80), srnd() > 0.5 ? NEON : '#f87171');
    }

    // Scratchy tag lines
    for (let i = 0; i < 25; i++) {
      const x1 = srnd() * W, y1 = srnd() * H;
      const x2 = x1 + srand(-200, 200), y2 = y1 + srand(-80, 80);
      drawLine(ctx, x1, y1, x2, y2, srnd() > 0.7 ? NEON : 'rgba(255,255,255,0.3)', srand(0.5, 3), srand(0.02, 0.07));
    }

    // Spray circles (random spots)
    for (let i = 0; i < 20; i++) {
      drawSprayPaint(ctx, srnd() * W, srnd() * H, srand(30, 120), srnd() > 0.5 ? NEON : NEON2, 40);
    }

    // Semi-transparent dark overlay so UI stays readable
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = '#080808';
    ctx.fillRect(0, 0, W, H);

    // Vignette edges
    const vignette = ctx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H);
    vignette.addColorStop(0,   'rgba(0,0,0,0)');
    vignette.addColorStop(0.7, 'rgba(0,0,0,0.2)');
    vignette.addColorStop(1,   'rgba(0,0,0,0.75)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, W, H);
  }

  window.addEventListener('resize', resize);
  // Wait for Syne font to load for text rendering
  document.fonts.ready.then(resize);
  resize();
})();

</script>
</body>
</html>
