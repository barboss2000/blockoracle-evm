<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>BTC Prediction Market</title>

<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script src="https://s3.tradingview.com/tv.js"></script>

<style>
body { background:#0b1220; color:white; font-family:Arial; text-align:center; }
.card { background:#1b2438; padding:25px; border-radius:15px; width:500px; margin:auto; }
button { padding:10px; margin:5px; border-radius:8px; border:none; cursor:pointer; font-weight:bold; }
.green   { background:#1db954; color:white; }
.red     { background:#e84142; color:white; }
.blue    { background:#5865f2; color:white; }
.yellow  { background:#f1c40f; color:#000; }
.orange  { background:#e67e22; color:white; }
.purple  { background:#9b59b6; color:white; }
select, input { padding:6px; border-radius:6px; border:none; margin:5px; background:#0d1b2e; color:white; }
.stat { margin:6px; }
button:disabled { opacity:0.4; cursor:not-allowed; }

.divider { border-top:1px solid #2e3f60; margin:14px 0; }

.duration-label { margin:10px 0 4px; font-size:13px; color:#aaa; }
.duration-group { display:flex; justify-content:center; gap:6px; margin-bottom:10px; flex-wrap:wrap; }
.dur-btn {
  padding:7px 14px; border-radius:20px; border:2px solid #2e3f60;
  background:#0d1b2e; color:#aaa; cursor:pointer; font-size:13px; font-weight:bold;
  transition: all 0.2s;
}
.dur-btn:hover { border-color:#5865f2; color:white; }
.dur-btn.active { border-color:#5865f2; background:#5865f2; color:white; }

.status-badge {
  display:inline-block; padding:3px 12px; border-radius:12px;
  font-size:12px; font-weight:bold; margin-left:6px;
}
.status-active  { background:#1db954; color:white; }
.status-ended   { background:#e84142; color:white; }
.status-waiting { background:#f1c40f; color:#000; }

.admin-panel {
  background:#0d1b2e; border-radius:10px; padding:14px; margin-top:14px;
  border:1px solid #2e3f60;
}
.admin-panel h4 { margin:0 0 10px; color:#aaa; font-size:12px; text-transform:uppercase; letter-spacing:1px; }

.bets-section { margin-top:16px; }
.bets-section h4 { color:#aaa; font-size:13px; text-transform:uppercase; letter-spacing:1px; margin-bottom:8px; }
.bet-item {
  background:#0d1b2e; border-radius:8px; padding:10px 14px;
  margin-bottom:6px; display:flex; align-items:center; justify-content:space-between;
  font-size:13px;
}
.bet-dir { font-weight:bold; padding:3px 10px; border-radius:12px; font-size:12px; }
.bet-dir.up   { background:#1db954; color:white; }
.bet-dir.down { background:#e84142; color:white; }
.bet-info { flex:1; margin:0 12px; text-align:left; }
.bet-info span { display:block; color:#aaa; font-size:11px; }
.bet-info strong { font-size:13px; color:white; }
.bet-timer { font-size:20px; font-weight:bold; color:#f1c40f; min-width:52px; text-align:right; }
.bet-timer.expired { color:#e84142; font-size:12px; font-weight:normal; }

/* Hint message under bet buttons */
#betHint { font-size:12px; color:#f1c40f; margin:4px 0 0; min-height:18px; }
</style>
</head>

<body>

<h2>BTC Prediction Market</h2>
<div id="tv_chart"></div>
<br>

<div class="card">

  <div class="stat"><b>Wallet:</b> <span id="wallet">Not connected</span></div>
  <div class="stat">
    <b>Round:</b> <span id="round">-</span>
    <span id="roundStatus" class="status-badge status-waiting">-</span>
  </div>
  <div class="stat"><b>Lock Price:</b> <span id="lockPrice">-</span></div>
  <div class="stat"><b>UP Pool:</b> <span id="upPool">0</span></div>
  <div class="stat"><b>DOWN Pool:</b> <span id="downPool">0</span></div>
  <div class="stat"><b>UP Probability:</b> <span id="probUp">0%</span></div>
  <div class="stat"><b>Round ends in:</b> <span id="timeLeft">-</span></div>

  <div class="divider"></div>

  <input id="amount" type="number" placeholder="Amount (ETH)" step="0.0001" min="0.0001"/>

  <div class="duration-label">Выбери длительность:</div>
  <div class="duration-group">
    <button class="dur-btn active" onclick="selectDuration(1, this)">1 min</button>
    <button class="dur-btn" onclick="selectDuration(2, this)">2 min</button>
    <button class="dur-btn" onclick="selectDuration(3, this)">3 min</button>
    <button class="dur-btn" onclick="selectDuration(4, this)">4 min</button>
    <button class="dur-btn" onclick="selectDuration(5, this)">5 min</button>
  </div>

  <button class="green" onclick="betUp()" id="btnUp" disabled>&#9650; Bet UP</button>
  <button class="red"   onclick="betDown()" id="btnDown" disabled>&#9660; Bet DOWN</button>
  <div id="betHint" style="font-size:12px;margin:4px 0;min-height:18px;"></div>
  <br>
  <button class="yellow" onclick="claim()" id="btnClaim" disabled>&#9733; Claim</button>
  <button class="blue"   onclick="connect()">Connect Wallet</button>

  <div class="divider"></div>

  <div class="admin-panel">
    <h4>&#9654; Round Management</h4>

    <div style="margin-bottom:8px;">

      <label style="font-size:13px;color:#aaa;">BTC Price ($):</label>
      <input id="lockPriceInput" type="number" placeholder="e.g. 65000" style="width:110px;"/>
      <button class="orange" id="btnFetchPrice" onclick="fetchBTCPrice()">&#8635; Auto</button>
    </div>

    <button class="green" onclick="startRound()" id="btnStart" disabled>&#9654; Start New Round</button>

    <div style="margin-top:10px;">
      <label style="font-size:13px;color:#aaa;">Close Price ($):</label>
      <input id="closePriceInput" type="number" placeholder="e.g. 65500" style="width:110px;"/>
      <button class="orange" onclick="fetchBTCPriceForSettle()">&#8635; Auto</button>
    </div>
    <button class="purple" onclick="settleRound()" id="btnSettle" disabled>&#9632; Settle Round (Owner)</button>
  </div>

  <div class="bets-section" id="betsSection" style="display:none;">
    <h4>My Active Bets</h4>
    <div id="betsList"></div>
  </div>

</div>

<script>

const CONTRACT_ADDRESS = "0x06D1181aF549bd7150050C6346AC9913f5b06e05";
const CHAIN_ID = 46630;

const abi = [
  "function betUp() payable",
  "function betDown() payable",
  "function claim(uint256,address)",
  "function startRound(uint256,uint256)",
  "function settleRound(uint256)",
  "function currentRound() view returns(uint256)",
  "function rounds(uint256) view returns(uint256,uint256,uint256,uint256,uint256,uint256,bool,bool)",
  "function pools(uint256,address) view returns(uint256,uint256)",
  "function owner() view returns(address)"
];

let provider, signer, contract, user, contractOwner;
let roundTimerInterval = null;
let selectedDuration = 1;
let activeBets = [];
let betsRenderInterval = null;
let isRoundActive = false; // KEY: tracks if betting is currently allowed
let alreadyBetThisRound = false; // tracks if user already bet in current round

function selectDuration(min, btn) {
  selectedDuration = min;
  document.querySelectorAll('.dur-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}

// Update bet buttons based on round state
function updateBetButtons() {
  const connected = !!user && !!contract;
  const canBet = connected && !alreadyBetThisRound;
  document.getElementById("btnUp").disabled = !canBet;
  document.getElementById("btnDown").disabled = !canBet;

  const hint = document.getElementById("betHint");
  if (hint) {
    if (connected && alreadyBetThisRound) {
      hint.innerText = "✓ You already bet in this round";
      hint.style.color = "#1db954";
    } else {
      hint.innerText = "";
    }
  }
}

function addActiveBet(direction, amount, durationMin, roundId) {
  const endTime = Math.floor(Date.now() / 1000) + durationMin * 60;
  activeBets.push({ direction, amount, endTime, roundId: roundId.toString(), durationMin });
  renderBets();
  if (!betsRenderInterval) {
    betsRenderInterval = setInterval(renderBets, 1000);
  }
}

function renderBets() {
  const list = document.getElementById('betsList');
  const section = document.getElementById('betsSection');
  if (activeBets.length === 0) { section.style.display = 'none'; return; }
  section.style.display = 'block';
  const now = Math.floor(Date.now() / 1000);
  list.innerHTML = activeBets.map(bet => {
    const left = bet.endTime - now;
    const timerHtml = left > 0
      ? `<div class="bet-timer">${formatTime(left)}</div>`
      : `<div class="bet-timer expired">Awaiting result</div>`;
    const dirClass = bet.direction === 'UP' ? 'up' : 'down';
    return `<div class="bet-item">
      <span class="bet-dir ${dirClass}">${bet.direction}</span>
      <div class="bet-info">
        <strong>${parseFloat(bet.amount).toFixed(4)} ETH</strong>
        <span>Round #${bet.roundId} &middot; ${bet.durationMin} min</span>
      </div>
      ${timerHtml}
    </div>`;
  }).join('');
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return m > 0 ? `${m}:${s.toString().padStart(2,'0')}` : `${s}s`;
}

async function connect() {
  if (!window.ethereum) { alert("MetaMask not found!"); return; }
  try {
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);

    const network = await provider.getNetwork();
    if (network.chainId !== CHAIN_ID) {
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x' + CHAIN_ID.toString(16) }]
        });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      } catch(e) {
        alert("Please switch MetaMask to Robinhood Chain Testnet (ChainID: 46630)");
        return;
      }
    }

    signer = provider.getSigner();
    user = await signer.getAddress();
    contract = new ethers.Contract(CONTRACT_ADDRESS, abi, signer);
    contractOwner = await contract.owner();

    document.getElementById("wallet").innerText = user.slice(0,6) + "..." + user.slice(-4);
    document.getElementById("btnClaim").disabled = false;
    document.getElementById("btnStart").disabled = false;

    if (user.toLowerCase() === contractOwner.toLowerCase()) {
      document.getElementById("btnSettle").disabled = false;
    }

    await loadData();
    setInterval(loadData, 10000);
  } catch(e) {
    alert("Connection error: " + e.message);
  }
}

async function loadData() {
  if (!contract) return;
  try {
    const roundId = await contract.currentRound();
    document.getElementById("round").innerText = roundId.toString();

    if (roundId.toNumber() === 0) {
      // No rounds yet
      isRoundActive = false;
      updateBetButtons();
      document.getElementById("roundStatus").innerText = "No rounds yet";
      document.getElementById("roundStatus").className = "status-badge status-waiting";
      document.getElementById("timeLeft").innerText = "-";
      document.getElementById("lockPrice").innerText = "-";
      return;
    }

    const pool = await contract.pools(roundId, ethers.constants.AddressZero);
    const up = parseFloat(ethers.utils.formatEther(pool[0]));
    const down = parseFloat(ethers.utils.formatEther(pool[1]));
    document.getElementById("upPool").innerText = up.toFixed(4) + " ETH";
    document.getElementById("downPool").innerText = down.toFixed(4) + " ETH";
    const total = up + down;
    document.getElementById("probUp").innerText = total > 0 ? (up / total * 100).toFixed(1) + "%" : "0%";

    const round = await contract.rounds(roundId);
    const endTime = round[1].toNumber();
    const lockPriceRaw = round[2].toNumber();
    const settled = round[6];

    document.getElementById("lockPrice").innerText = lockPriceRaw > 0 ? "$" + lockPriceRaw.toLocaleString() : "-";

    const now = Math.floor(Date.now() / 1000);

    if (settled) {
      // Round settled — can start new one
      isRoundActive = false;
      alreadyBetThisRound = false;
      document.getElementById("roundStatus").innerText = "Settled";
      document.getElementById("roundStatus").className = "status-badge status-waiting";
      document.getElementById("timeLeft").innerText = "Settled ✓";
      if (roundTimerInterval) { clearInterval(roundTimerInterval); roundTimerInterval = null; }
      // Show result
      const upWon = round[7];
      const closePrice = round[3].toNumber();
      document.getElementById("timeLeft").innerText = `Settled ✓ | Close: $${closePrice.toLocaleString()} | ${upWon ? "⬆ UP WON" : "⬇ DOWN WON"}`;
    } else if (now >= endTime) {
      // Round ended but not settled yet
      isRoundActive = false;
      alreadyBetThisRound = false;
      document.getElementById("roundStatus").innerText = "Ended";
      document.getElementById("roundStatus").className = "status-badge status-ended";
      document.getElementById("timeLeft").innerText = "Ended — awaiting settlement";
      if (roundTimerInterval) { clearInterval(roundTimerInterval); roundTimerInterval = null; }
    } else {
      // Round is active — bets allowed
      isRoundActive = true;
      document.getElementById("roundStatus").innerText = "Active";
      document.getElementById("roundStatus").className = "status-badge status-active";
      startRoundTimer(endTime);
    }

    // Check if user already bet this round
    if (user && isRoundActive) {
      const userBet = await contract.pools(roundId, user);
      alreadyBetThisRound = userBet[0].gt(0) || userBet[1].gt(0);
    } else if (!isRoundActive) {
      alreadyBetThisRound = false;
    }

    updateBetButtons();
  } catch(e) {
    console.error("loadData error:", e);
  }
}

function startRoundTimer(endTime) {
  if (roundTimerInterval) clearInterval(roundTimerInterval);
  roundTimerInterval = setInterval(() => {
    const now = Math.floor(Date.now() / 1000);
    const left = endTime - now;
    if (left > 0) {
      document.getElementById("timeLeft").innerText = formatTime(left);
    } else {
      isRoundActive = false;
      updateBetButtons();
      document.getElementById("timeLeft").innerText = "Ended — awaiting settlement";
      document.getElementById("roundStatus").innerText = "Ended";
      document.getElementById("roundStatus").className = "status-badge status-ended";
      clearInterval(roundTimerInterval);
      roundTimerInterval = null;
      loadData();
    }
  }, 1000);
}

async function fetchBTCPrice() {
  try {
    document.getElementById("btnFetchPrice").innerText = "...";
    const res = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd");
    const data = await res.json();
    document.getElementById("lockPriceInput").value = Math.round(data.bitcoin.usd);
    document.getElementById("btnFetchPrice").innerText = "✓";
    setTimeout(() => document.getElementById("btnFetchPrice").innerText = "↻ Auto", 2000);
  } catch(e) {
    alert("Could not fetch BTC price. Enter manually.");
    document.getElementById("btnFetchPrice").innerText = "↻ Auto";
  }
}

async function fetchBTCPriceForSettle() {
  try {
    const res = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd");
    const data = await res.json();
    document.getElementById("closePriceInput").value = Math.round(data.bitcoin.usd);
  } catch(e) {
    alert("Could not fetch BTC price. Enter manually.");
  }
}

async function startRound() {
  if (!checkConnected()) return;
  const duration = selectedDuration;
  const lockPrice = parseInt(document.getElementById("lockPriceInput").value);
  if (!lockPrice || lockPrice <= 0) { alert("Enter BTC lock price (click ↻ Auto or type manually)"); return; }
  try {
    document.getElementById("btnStart").disabled = true;
    document.getElementById("btnStart").innerText = "Starting...";
    const tx = await contract.startRound(duration, lockPrice);
    await tx.wait();
    await loadData();
  } catch(e) {
    alert("Start round failed: " + (e.reason || e.message));
  } finally {
    document.getElementById("btnStart").disabled = false;
    document.getElementById("btnStart").innerText = "▶ Start New Round";
  }
}

async function settleRound() {
  if (!checkConnected()) return;
  if (user.toLowerCase() !== contractOwner.toLowerCase()) {
    alert("Only the contract owner can settle rounds");
    return;
  }
  const closePrice = parseInt(document.getElementById("closePriceInput").value);
  if (!closePrice || closePrice <= 0) { alert("Enter BTC close price (click ↻ Auto or type manually)"); return; }
  try {
    document.getElementById("btnSettle").disabled = true;
    document.getElementById("btnSettle").innerText = "Settling...";
    const tx = await contract.settleRound(closePrice);
    await tx.wait();
    await loadData();
  } catch(e) {
    alert("Settle failed: " + (e.reason || e.message));
  } finally {
    document.getElementById("btnSettle").disabled = false;
    document.getElementById("btnSettle").innerText = "■ Settle Round (Owner)";
  }
}

// Auto-start round when user clicks Bet without active round
async function autoStartRound() {
  const lockPriceInput = document.getElementById("lockPriceInput").value;
  let lockPrice = parseInt(lockPriceInput);

  // If no price entered, fetch automatically
  if (!lockPrice || lockPrice <= 0) {
    try {
      const res = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd");
      const data = await res.json();
      lockPrice = Math.round(data.bitcoin.usd);
      document.getElementById("lockPriceInput").value = lockPrice;
    } catch(e) {
      alert("Could not fetch BTC price. Please enter price manually in Round Management.");
      return;
    }
  }

  try {
    const tx = await contract.startRound(selectedDuration, lockPrice);
    await tx.wait();
    await loadData();
  } catch(e) {
    alert("Could not start round: " + (e.reason || e.message));
  }
}

async function betUp() {
  if (!checkConnected()) return;
  const amount = document.getElementById("amount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter a valid amount"); return; }
  try {
    document.getElementById("btnUp").disabled = true;
    document.getElementById("btnDown").disabled = true;
    // Auto-start round if not active
    if (!isRoundActive) {
      await autoStartRound();
      if (!isRoundActive) return; // failed to start
    }
    const roundId = await contract.currentRound();
    const tx = await contract.betUp({ value: ethers.utils.parseEther(amount) });
    await tx.wait();
    addActiveBet('UP', amount, selectedDuration, roundId);
    await loadData();
  } catch(e) {
    alert("Bet UP failed: " + (e.reason || e.message));
  } finally {
    updateBetButtons();
  }
}

async function betDown() {
  if (!checkConnected()) return;
  const amount = document.getElementById("amount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter a valid amount"); return; }
  try {
    document.getElementById("btnDown").disabled = true;
    document.getElementById("btnUp").disabled = true;
    // Auto-start round if not active
    if (!isRoundActive) {
      await autoStartRound();
      if (!isRoundActive) return; // failed to start
    }
    const roundId = await contract.currentRound();
    const tx = await contract.betDown({ value: ethers.utils.parseEther(amount) });
    await tx.wait();
    addActiveBet('DOWN', amount, selectedDuration, roundId);
    await loadData();
  } catch(e) {
    alert("Bet DOWN failed: " + (e.reason || e.message));
  } finally {
    updateBetButtons();
  }
}

async function claim() {
  if (!checkConnected()) return;
  try {
    const roundId = await contract.currentRound();
    const prevRound = roundId.sub(1);
    const tx = await contract.claim(prevRound, user);
    await tx.wait();
    activeBets = activeBets.filter(b => b.endTime > Math.floor(Date.now() / 1000));
    renderBets();
    alert("Claimed!");
  } catch(e) {
    alert("Claim failed: " + (e.reason || e.message));
  }
}

function checkConnected() {
  if (!user || !contract) { alert("Please connect your wallet first"); return false; }
  return true;
}

new TradingView.widget({
  "container_id": "tv_chart",
  "symbol": "BINANCE:BTCUSDT",
  "interval": "1",
  "theme": "dark",
  "width": "100%",
  "height": "400"
});

</script>
</body>
</html>
