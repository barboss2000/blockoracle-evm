<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BlockOracle â€” Robinhood Chain</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Syne:wght@700;800&display=swap" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script src="https://s3.tradingview.com/tv.js"></script>
<style>
:root {
  --neon:  #d5fd51;
  --neon-dim:  rgba(213,253,81,0.12);
  --neon-dim2: rgba(213,253,81,0.06);
  --black:    #0a0a0a;
  --surface:  #111111;
  --surface2: #181818;
  --border:   #2a2a2a;
  --border-light: #333;
  --text:     #ffffff;
  --text-muted: #666;
  --text-dim: #444;
  --up:   #4ade80;
  --down: #f87171;
  --up-dim:   rgba(74,222,128,0.10);
  --down-dim: rgba(248,113,113,0.10);
}
*{ margin:0; padding:0; box-sizing:border-box; }

body {
  background: #0d1a0a;
  color: var(--text);
  font-family: 'DM Mono', monospace;
  min-height: 100vh;
  overflow-x: hidden;
}

#graffiti-bg {
  position: fixed; inset: 0;
  width: 100%; height: 100%;
  pointer-events: none; z-index: 0;
}

.page { position: relative; z-index: 1; display: flex; flex-direction: column; height: 100vh; }

/* â”€â”€ Header â”€â”€ */
.header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  background: rgba(10,10,10,0.96);
  backdrop-filter: blur(12px);
  z-index: 100; flex-shrink: 0;
}
.logo { display:flex; align-items:center; gap:10px; }
.logo-icon {
  width:26px; height:26px; background:var(--neon);
  clip-path: polygon(50% 0%,100% 25%,100% 75%,50% 100%,0% 75%,0% 25%);
  animation: pulse-logo 3s ease-in-out infinite;
}
@keyframes pulse-logo {
  0%,100%{ box-shadow:0 0 0 0 rgba(213,253,81,0.4); }
  50%    { box-shadow:0 0 20px 4px rgba(213,253,81,0.2); }
}
.logo-text { font-family:'Syne',sans-serif; font-weight:800; font-size:15px; letter-spacing:-0.5px; }
.logo-text span { color:var(--neon); }
.header-right { display:flex; align-items:center; gap:10px; }
.chain-badge {
  font-size:10px; color:var(--text-muted); border:1px solid var(--border);
  padding:4px 10px; border-radius:4px; letter-spacing:1px; text-transform:uppercase;
}
.btn-faucet {
  background:transparent; color:var(--neon); border:1px solid rgba(213,253,81,0.35);
  padding:7px 14px; border-radius:6px; font-family:'DM Mono',monospace; font-size:11px;
  cursor:pointer; letter-spacing:0.5px; text-decoration:none; transition:all 0.2s;
  display:inline-flex; align-items:center; gap:5px;
}
.btn-faucet:hover { background:var(--neon-dim); border-color:var(--neon); }
.btn-connect {
  background:var(--neon); color:var(--black); border:none;
  padding:7px 16px; border-radius:6px; font-family:'DM Mono',monospace;
  font-size:11px; font-weight:500; cursor:pointer; transition:all 0.2s;
}
.btn-connect:hover { background:#c5ed41; }
.btn-connect.connected {
  background:var(--surface2); color:var(--neon);
  border:1px solid var(--border); cursor:default;
}

/* â”€â”€ Coin tabs â”€â”€ */
.coin-tabs {
  display: flex; gap: 6px; padding: 10px 24px;
  background: rgba(10,10,10,0.85);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0; overflow-x: auto;
}
.coin-tab {
  display: flex; align-items: center; gap: 7px;
  padding: 7px 16px; border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--surface2);
  cursor: pointer; transition: all 0.18s;
  white-space: nowrap;
}
.coin-tab:hover { border-color: var(--neon); }
.coin-tab.active { background: var(--neon-dim); border-color: var(--neon); }
.coin-icon {
  width: 22px; height: 22px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 11px; font-weight: 700; font-family: 'Syne', sans-serif;
}
.coin-name { font-size: 13px; font-weight: 500; color: var(--text); }
.coin-sym  { font-size: 10px; color: var(--text-muted); }
.coin-price-small { font-size: 11px; color: var(--neon); margin-left: 4px; }

/* â”€â”€ Main body â€” 2 columns â”€â”€ */
.body-layout {
  display: grid;
  grid-template-columns: 1fr 420px;
  flex: 1;
  overflow: hidden;
  min-height: 0;
}

/* Left: chart */
.chart-col {
  display: flex; flex-direction: column;
  border-right: 1px solid var(--border);
  overflow: hidden;
}
.chart-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 16px;
  background: rgba(10,10,10,0.7);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.chart-coin-name {
  font-family: 'Syne', sans-serif; font-size: 16px; font-weight: 800;
  display: flex; align-items: center; gap: 8px;
}
.chart-price { font-size: 22px; font-family:'Syne',sans-serif; font-weight:800; color:var(--neon); }
.chart-change { font-size: 12px; padding: 2px 8px; border-radius: 4px; }
.chart-change.pos { background:var(--up-dim); color:var(--up); }
.chart-change.neg { background:var(--down-dim); color:var(--down); }
#tv_chart { flex: 1; min-height: 0; }

/* Right: bet panel */
.bet-col {
  display: flex; flex-direction: column;
  overflow-y: auto;
  background: rgba(10,10,10,0.6);
  backdrop-filter: blur(8px);
}

/* Stats panel */
.stats-panel {
  background: rgba(17,17,17,0.9);
  border-bottom: 1px solid var(--border);
  padding: 14px 16px;
  flex-shrink: 0;
}
.round-row {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 10px;
}
.round-label { font-size:9px; color:var(--text-muted); letter-spacing:1.5px; text-transform:uppercase; }
.round-num { font-size:13px; color:var(--text); margin-top:2px; }
.status-pill {
  font-size:9px; font-weight:500; padding:3px 9px; border-radius:20px;
  letter-spacing:1px; text-transform:uppercase;
}
.status-active  { background:rgba(74,222,128,0.15); color:var(--up); border:1px solid rgba(74,222,128,0.3); }
.status-ended   { background:rgba(248,113,113,0.12); color:var(--down); border:1px solid rgba(248,113,113,0.3); }
.status-waiting { background:var(--neon-dim); color:var(--neon); border:1px solid rgba(213,253,81,0.3); }

.pool-bar-labels { display:flex; justify-content:space-between; font-size:10px; margin-bottom:5px; }
.up-label { color:var(--up); }
.down-label { color:var(--down); }
.pool-bar-track {
  height:5px; background:var(--down-dim); border-radius:3px;
  overflow:hidden; border:1px solid var(--border);
}
.pool-bar-fill {
  height:100%; background:linear-gradient(90deg,var(--up),#22c55e);
  border-radius:3px; transition:width 0.6s ease;
}

.stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px; }
.stat-item { background:var(--surface2); border:1px solid var(--border); border-radius:6px; padding:8px 10px; }
.stat-label { font-size:9px; color:var(--text-muted); letter-spacing:1.5px; text-transform:uppercase; margin-bottom:3px; }
.stat-value { font-size:13px; color:var(--text); }
.stat-value.neon { color:var(--neon); }

.result-banner {
  display:none; padding:10px 14px; border-radius:6px; margin-top:10px;
  text-align:center; font-family:'Syne',sans-serif; font-weight:700;
  font-size:13px; letter-spacing:0.5px;
}
.result-banner.up-won { background:var(--up-dim); border:1px solid rgba(74,222,128,0.3); color:var(--up); }
.result-banner.down-won { background:var(--down-dim); border:1px solid rgba(248,113,113,0.3); color:var(--down); }
.result-banner.show { display:block; }

/* Bet form */
.bet-form {
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.section-title {
  font-size:9px; color:var(--text-muted); letter-spacing:2px;
  text-transform:uppercase; margin-bottom:12px;
}
.amount-input-wrap { position:relative; margin-bottom:12px; }
.amount-input {
  width:100%; background:var(--surface2); border:1px solid var(--border);
  border-radius:8px; padding:12px 44px 12px 14px;
  font-family:'DM Mono',monospace; font-size:18px; color:var(--text); outline:none;
  transition:border-color 0.2s;
}
.amount-input:focus { border-color:var(--neon); }
.amount-input::placeholder { color:var(--text-dim); }
.amount-suffix {
  position:absolute; right:12px; top:50%; transform:translateY(-50%);
  font-size:11px; color:var(--text-muted);
}
.dur-label { font-size:9px; color:var(--text-muted); letter-spacing:2px; text-transform:uppercase; margin-bottom:7px; }
.dur-group { display:flex; gap:5px; margin-bottom:14px; }
.dur-btn {
  flex:1; padding:7px 4px; background:var(--surface2); border:1px solid var(--border);
  border-radius:6px; color:var(--text-muted); font-family:'DM Mono',monospace;
  font-size:11px; cursor:pointer; transition:all 0.15s; text-align:center;
}
.dur-btn:hover { border-color:var(--neon); color:var(--text); }
.dur-btn.active { background:var(--neon-dim); border-color:var(--neon); color:var(--neon); }

.bet-buttons { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px; }
.btn-up,.btn-down {
  padding:14px; border:none; border-radius:8px;
  font-family:'Syne',sans-serif; font-size:14px; font-weight:700;
  cursor:pointer; transition:all 0.2s; display:flex; align-items:center; justify-content:center; gap:6px;
}
.btn-up { background:var(--up-dim); color:var(--up); border:1px solid rgba(74,222,128,0.3); }
.btn-up:hover:not(:disabled) { background:var(--up); color:var(--black); transform:translateY(-2px); box-shadow:0 6px 20px rgba(74,222,128,0.25); }
.btn-up:disabled { opacity:0.3; cursor:not-allowed; }
.btn-down { background:var(--down-dim); color:var(--down); border:1px solid rgba(248,113,113,0.3); }
.btn-down:hover:not(:disabled) { background:var(--down); color:var(--black); transform:translateY(-2px); box-shadow:0 6px 20px rgba(248,113,113,0.25); }
.btn-down:disabled { opacity:0.3; cursor:not-allowed; }
#betHint { text-align:center; font-size:10px; min-height:16px; margin-bottom:8px; }
.btn-claim {
  width:100%; padding:11px; background:var(--neon-dim); border:1px solid rgba(213,253,81,0.3);
  border-radius:8px; color:var(--neon); font-family:'DM Mono',monospace; font-size:12px;
  cursor:pointer; transition:all 0.2s;
}
.btn-claim:hover:not(:disabled) { background:var(--neon); color:var(--black); }
.btn-claim:disabled { opacity:0.3; cursor:not-allowed; }

/* Active bets */
.bets-section { padding:14px 16px; border-bottom:1px solid var(--border); }
.bets-title { font-size:9px; color:var(--text-muted); letter-spacing:2px; text-transform:uppercase; margin-bottom:10px; }
.bet-item {
  display:flex; align-items:center; gap:10px; padding:9px 11px;
  background:var(--surface2); border:1px solid var(--border);
  border-radius:7px; margin-bottom:5px;
}
.bet-dir-badge {
  font-size:9px; font-weight:600; padding:2px 7px; border-radius:4px; letter-spacing:1px; min-width:40px; text-align:center;
}
.bet-dir-badge.up   { background:var(--up-dim); color:var(--up); border:1px solid rgba(74,222,128,0.2); }
.bet-dir-badge.down { background:var(--down-dim); color:var(--down); border:1px solid rgba(248,113,113,0.2); }
.bet-info { flex:1; }
.bet-amount { font-size:12px; color:var(--text); }
.bet-meta { font-size:9px; color:var(--text-muted); margin-top:1px; }
.bet-timer { font-family:'Syne',sans-serif; font-size:16px; font-weight:700; color:var(--neon); min-width:46px; text-align:right; }
.bet-timer.expired { font-family:'DM Mono',monospace; font-size:9px; font-weight:400; color:var(--down); letter-spacing:1px; }

/* Owner panel */
.owner-panel {
  padding: 14px 16px;
  border-bottom: 1px solid rgba(213,253,81,0.15);
  background: rgba(213,253,81,0.03);
}
.owner-panel-title { font-size:9px; color:var(--neon); letter-spacing:2px; text-transform:uppercase; margin-bottom:12px; }
.owner-stats { display:grid; grid-template-columns:1fr 1fr 1fr; gap:6px; margin-bottom:10px; }
.owner-stat { background:var(--surface2); border:1px solid var(--border); border-radius:5px; padding:7px 8px; text-align:center; }
.owner-stat-label { font-size:8px; color:var(--text-muted); letter-spacing:1px; text-transform:uppercase; margin-bottom:2px; }
.owner-stat-val   { font-size:11px; color:var(--neon); }
.owner-row { display:flex; align-items:center; gap:6px; margin-bottom:7px; }
.owner-input {
  flex:1; background:var(--surface2); border:1px solid var(--border); border-radius:5px;
  padding:8px 10px; font-family:'DM Mono',monospace; font-size:12px; color:var(--text); outline:none;
}
.owner-input:focus { border-color:var(--neon); }
.btn-owner { padding:8px 11px; border:none; border-radius:5px; font-family:'DM Mono',monospace; font-size:11px; cursor:pointer; transition:all 0.2s; white-space:nowrap; }
.btn-deposit      { background:var(--neon-dim); color:var(--neon); border:1px solid rgba(213,253,81,0.3); }
.btn-deposit:hover { background:var(--neon); color:var(--black); }
.btn-withdraw     { background:var(--up-dim); color:var(--up); border:1px solid rgba(74,222,128,0.3); }
.btn-withdraw:hover { background:var(--up); color:var(--black); }
.btn-withdraw-all { background:var(--down-dim); color:var(--down); border:1px solid rgba(248,113,113,0.3); }
.btn-withdraw-all:hover { background:var(--down); color:var(--black); }

@media (max-width: 900px) {
  .body-layout { grid-template-columns: 1fr; grid-template-rows: 300px 1fr; }
  .chart-col { border-right:none; border-bottom:1px solid var(--border); }
  .bet-col { max-height: none; }
}
</style>
</head>
<body>
<canvas id="graffiti-bg"></canvas>
<div class="page">

  <!-- Header -->
  <header class="header">
    <div class="logo">
      <div class="logo-icon"></div>
      <div class="logo-text">BLOCK<span>ORACLE</span></div>
    </div>
    <div class="header-right">
      <a href="https://faucet.testnet.chain.robinhood.com/?error=undefined&address=0x6d4D522f22681b76483BF327ff7Bb6748a68Da5c&step=auth" target="_blank" class="btn-faucet">ðŸ’§ Faucet</a>
      <div class="chain-badge">Robinhood Chain Â· 46630</div>
      <button class="btn-connect" id="btnConnect" onclick="connect()">Connect Wallet</button>
    </div>
  </header>

  <!-- Coin tabs -->
  <div class="coin-tabs">
    <div class="coin-tab active" onclick="selectCoin('BTC',this)">
      <div class="coin-icon" style="background:#f7931a22;color:#f7931a;">â‚¿</div>
      <div><div class="coin-name">Bitcoin</div><div class="coin-sym">BTC</div></div>
      <span class="coin-price-small" id="price-BTC">â€”</span>
    </div>
    <div class="coin-tab" onclick="selectCoin('ETH',this)">
      <div class="coin-icon" style="background:#627eea22;color:#627eea;">Îž</div>
      <div><div class="coin-name">Ethereum</div><div class="coin-sym">ETH</div></div>
      <span class="coin-price-small" id="price-ETH">â€”</span>
    </div>
    <div class="coin-tab" onclick="selectCoin('BNB',this)">
      <div class="coin-icon" style="background:#f0b90b22;color:#f0b90b;">B</div>
      <div><div class="coin-name">BNB</div><div class="coin-sym">BNB</div></div>
      <span class="coin-price-small" id="price-BNB">â€”</span>
    </div>
    <div class="coin-tab" onclick="selectCoin('SOL',this)">
      <div class="coin-icon" style="background:#9945ff22;color:#9945ff;">â—Ž</div>
      <div><div class="coin-name">Solana</div><div class="coin-sym">SOL</div></div>
      <span class="coin-price-small" id="price-SOL">â€”</span>
    </div>
    <div class="coin-tab" onclick="selectCoin('XRP',this)">
      <div class="coin-icon" style="background:#00aae422;color:#00aae4;">âœ•</div>
      <div><div class="coin-name">Ripple</div><div class="coin-sym">XRP</div></div>
      <span class="coin-price-small" id="price-XRP">â€”</span>
    </div>
  </div>

  <!-- Body: chart left + bets right -->
  <div class="body-layout">

    <!-- Chart column -->
    <div class="chart-col">
      <div class="chart-header">
        <div class="chart-coin-name" id="chartCoinName">
          <span style="color:#f7931a">â‚¿</span> BTC/USDT
        </div>
        <div style="display:flex;align-items:center;gap:10px;">
          <div class="chart-price" id="chartPrice">â€”</div>
          <div class="chart-change pos" id="chartChange">â€”</div>
        </div>
      </div>
      <div id="tv_chart"></div>
    </div>

    <!-- Bet column -->
    <div class="bet-col">

      <!-- Stats -->
      <div class="stats-panel">
        <div class="round-row">
          <div>
            <div class="round-label">Round</div>
            <div class="round-num" id="round">â€”</div>
          </div>
          <div style="text-align:center;">
            <div class="round-label">Lock Price</div>
            <div class="round-num" id="lockPrice">â€”</div>
          </div>
          <span id="roundStatus" class="status-pill status-waiting">â€”</span>
        </div>
        <div class="pool-bar-wrap">
          <div class="pool-bar-labels">
            <span class="up-label">â–² UP &nbsp;<span id="upPool">0.0000</span></span>
            <span style="color:var(--text-muted)" id="probUp">0%</span>
            <span class="down-label"><span id="downPool">0.0000</span>&nbsp; DOWN â–¼</span>
          </div>
          <div class="pool-bar-track">
            <div class="pool-bar-fill" id="poolBar" style="width:50%"></div>
          </div>
        </div>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-label">Wallet</div>
            <div class="stat-value" id="wallet" style="font-size:11px;">Not connected</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">Round ends in</div>
            <div class="stat-value neon" id="timeLeftSmall">â€”</div>
          </div>
        </div>
        <div class="result-banner" id="resultBanner"></div>
      </div>

      <!-- Bet form -->
      <div class="bet-form">
        <div class="section-title">Place your bet</div>
        <div class="amount-input-wrap">
          <input class="amount-input" id="amount" type="number" placeholder="0.0001" step="0.0001" min="0.0001"/>
          <span class="amount-suffix">ETH</span>
        </div>
        <div class="dur-label">Duration</div>
        <div class="dur-group">
          <button class="dur-btn active" onclick="selectDuration(1,this)">1m</button>
          <button class="dur-btn" onclick="selectDuration(2,this)">2m</button>
          <button class="dur-btn" onclick="selectDuration(3,this)">3m</button>
          <button class="dur-btn" onclick="selectDuration(4,this)">4m</button>
          <button class="dur-btn" onclick="selectDuration(5,this)">5m</button>
        </div>
        <div class="bet-buttons">
          <button class="btn-up"   id="btnUp"   onclick="betUp()"   disabled>â–² &nbsp;UP</button>
          <button class="btn-down" id="btnDown" onclick="betDown()" disabled>â–¼ &nbsp;DOWN</button>
        </div>
        <div id="betHint"></div>
        <button class="btn-claim" id="btnClaim" onclick="claim()" disabled>â˜… &nbsp;Claim Winnings</button>
      </div>

      <!-- Active bets -->
      <div class="bets-section" id="betsSection" style="display:none;">
        <div class="bets-title">My Active Bets</div>
        <div id="betsList"></div>
      </div>

      <!-- Owner panel -->
      <div class="owner-panel" id="ownerPanel" style="display:none;">
        <div class="owner-panel-title">â¬¡ &nbsp;Owner Controls</div>
        <div class="owner-stats">
          <div class="owner-stat"><div class="owner-stat-label">Contract</div><div class="owner-stat-val" id="ownerBalContract">â€”</div></div>
          <div class="owner-stat"><div class="owner-stat-label">My Profit</div><div class="owner-stat-val" id="ownerBalProfit">â€”</div></div>
          <div class="owner-stat"><div class="owner-stat-label">Liquidity</div><div class="owner-stat-val" id="ownerBalLiquidity">â€”</div></div>
        </div>
        <div class="owner-row">
          <input class="owner-input" id="depositAmount" type="number" placeholder="ETH amount" step="0.001"/>
          <button class="btn-owner btn-deposit" onclick="ownerDeposit()">â¬† Deposit</button>
        </div>
        <div class="owner-row">
          <input class="owner-input" id="withdrawAmount" type="number" placeholder="ETH (0=all)" step="0.001"/>
          <button class="btn-owner btn-withdraw" onclick="ownerWithdraw()">â¬‡ Withdraw</button>
          <button class="btn-owner btn-withdraw-all" onclick="ownerWithdrawAll()">All</button>
        </div>
      </div>

    </div>
  </div>
</div>

<script>
const CONTRACT_ADDRESS = "0xE1D77C412785eD34B991f871fFc51f6458deB997";
const CHAIN_ID = 46630;

const abi = [
  "function betUp() payable",
  "function betDown() payable",
  "function claim(uint256,address)",
  "function startRound(uint256,uint256)",
  "function settleRound(uint256)",
  "function currentRound() view returns(uint256)",
  "function rounds(uint256) view returns(uint256,uint256,uint256,uint256,uint256,uint256,bool,bool)",
  "function pools(uint256,address) view returns(uint256,uint256)",
  "function owner() view returns(address)",
  "function depositLiquidity() payable",
  "function withdrawProfit(uint256)",
  "function withdrawLiquidity(uint256)",
  "function balanceInfo() view returns(uint256,uint256,uint256)",
  "function previewPayout(uint256,address) view returns(uint256)",
  "function ownerProfit() view returns(uint256)",
  "function liquidityPool() view returns(uint256)"
];

let provider, signer, contract, user, contractOwner;
let roundTimerInterval = null;
let selectedDuration = 1;
let activeBets = [];
let betsRenderInterval = null;
let isRoundActive = false;
let alreadyBetThisRound = false;

// â”€â”€ Coin config â”€â”€
const COINS = {
  BTC: { symbol: 'BINANCE:BTCUSDT', binance: 'BTCUSDT', name: 'â‚¿ BTC/USDT', color: '#f7931a', cgId: 'bitcoin' },
  ETH: { symbol: 'BINANCE:ETHUSDT', binance: 'ETHUSDT', name: 'Îž ETH/USDT', color: '#627eea', cgId: 'ethereum' },
  BNB: { symbol: 'BINANCE:BNBUSDT', binance: 'BNBUSDT', name: 'B BNB/USDT', color: '#f0b90b', cgId: 'binancecoin' },
  SOL: { symbol: 'BINANCE:SOLUSDT', binance: 'SOLUSDT', name: 'â—Ž SOL/USDT', color: '#9945ff', cgId: 'solana' },
  XRP: { symbol: 'BINANCE:XRPUSDT', binance: 'XRPUSDT', name: 'âœ• XRP/USDT', color: '#00aae4', cgId: 'ripple' },
};
let selectedCoin = 'BTC';
let tvWidget = null;

// Cache of live prices
const priceCache = {};

function selectCoin(coin, el) {
  selectedCoin = coin;
  document.querySelectorAll('.coin-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  const cfg = COINS[coin];

  // Update chart header name
  document.getElementById('chartCoinName').innerHTML =
    `<span style="color:${cfg.color}">${cfg.name.split(' ')[0]}</span> ${cfg.name.slice(cfg.name.indexOf(' ')+1)}`;

  // Immediately update price from cache if available
  if (priceCache[coin]) {
    document.getElementById('chartPrice').innerText = priceCache[coin].price;
    const changeEl = document.getElementById('chartChange');
    changeEl.innerText = priceCache[coin].change;
    changeEl.className = 'chart-change ' + priceCache[coin].dir;
  } else {
    document.getElementById('chartPrice').innerText = 'â€”';
    document.getElementById('chartChange').innerText = 'â€”';
    // Fetch immediately
    loadAllPrices();
  }

  // Re-render TradingView widget for selected coin
  document.getElementById('tv_chart').innerHTML = '';
  tvWidget = new TradingView.widget({
    container_id: 'tv_chart',
    symbol: cfg.symbol,
    interval: '1',
    theme: 'dark',
    width: '100%',
    height: '100%',
    autosize: true,
    hide_top_toolbar: false,
    hide_side_toolbar: true,
    allow_symbol_change: false,
  });
}

// â”€â”€ Real-time prices via Binance WebSocket â”€â”€
function startPriceWebSocket() {
  const streams = 'btcusdt@ticker/ethusdt@ticker/bnbusdt@ticker/solusdt@ticker/xrpusdt@ticker';
  const ws = new WebSocket(`wss://stream.binance.com:9443/stream?streams=${streams}`);

  ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    const t = msg.data;
    if (!t) return;
    const coinKey = Object.keys(COINS).find(k => COINS[k].binance === t.s);
    if (!coinKey) return;

    const price  = parseFloat(t.c);  // current price
    const change = parseFloat(t.P);  // 24h change %
    const fmt = price < 10 ? price.toFixed(4) : price < 1000 ? price.toFixed(2) : Math.round(price).toLocaleString();
    const changeStr = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
    const dir = change >= 0 ? 'pos' : 'neg';

    // Store in cache instantly
    priceCache[coinKey] = { price: '$' + fmt, change: changeStr, dir, raw: price };

    // Update tab badge
    const priceEl = document.getElementById('price-' + coinKey);
    if (priceEl) priceEl.innerText = '$' + fmt;

    // Update chart header instantly if this is the selected coin
    if (coinKey === selectedCoin) {
      document.getElementById('chartPrice').innerText = '$' + fmt;
      const changeEl = document.getElementById('chartChange');
      changeEl.innerText = changeStr;
      changeEl.className = 'chart-change ' + dir;
    }
  };

  ws.onclose = () => {
    // Reconnect after 3s if disconnected
    setTimeout(startPriceWebSocket, 3000);
  };

  ws.onerror = () => ws.close();
}

// Fallback REST fetch (used on first load before WS connects)
async function loadAllPrices() {
  try {
    const res = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbols=["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT"]`);
    const data = await res.json();
    if (!Array.isArray(data)) return;
    for (const t of data) {
      const coinKey = Object.keys(COINS).find(k => COINS[k].binance === t.symbol);
      if (!coinKey) continue;
      const price  = parseFloat(t.lastPrice);
      const change = parseFloat(t.priceChangePercent);
      const fmt = price < 10 ? price.toFixed(4) : price < 1000 ? price.toFixed(2) : Math.round(price).toLocaleString();
      const changeStr = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
      const dir = change >= 0 ? 'pos' : 'neg';
      priceCache[coinKey] = { price: '$' + fmt, change: changeStr, dir, raw: price };
      const priceEl = document.getElementById('price-' + coinKey);
      if (priceEl) priceEl.innerText = '$' + fmt;
      if (coinKey === selectedCoin) {
        document.getElementById('chartPrice').innerText = '$' + fmt;
        const changeEl = document.getElementById('chartChange');
        changeEl.innerText = changeStr;
        changeEl.className = 'chart-change ' + dir;
      }
    }
  } catch(e) { console.warn('Price load failed', e.message); }
}

// â”€â”€ Duration â”€â”€
function selectDuration(min, btn) {
  selectedDuration = min;
  document.querySelectorAll('.dur-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}

// â”€â”€ Bet buttons â”€â”€
function updateBetButtons() {
  const connected = !!user && !!contract;
  const canBet = connected && !alreadyBetThisRound;
  document.getElementById("btnUp").disabled = !canBet;
  document.getElementById("btnDown").disabled = !canBet;
  const hint = document.getElementById("betHint");
  if (connected && alreadyBetThisRound) {
    hint.innerText = "âœ“ Already bet this round";
    hint.style.color = "var(--up)";
  } else { hint.innerText = ""; }
}

// â”€â”€ Active bets â”€â”€
function addActiveBet(direction, amount, durationMin, roundId) {
  const endTime = Math.floor(Date.now() / 1000) + durationMin * 60;
  activeBets.push({ direction, amount, endTime, roundId: roundId.toString(), durationMin, coin: selectedCoin });
  renderBets();
  if (!betsRenderInterval) betsRenderInterval = setInterval(renderBets, 1000);
}

function renderBets() {
  const list = document.getElementById('betsList');
  const section = document.getElementById('betsSection');
  if (!activeBets.length) { section.style.display='none'; return; }
  section.style.display = 'block';
  const now = Math.floor(Date.now() / 1000);
  list.innerHTML = activeBets.map(bet => {
    const left = bet.endTime - now;
    const timer = left > 0
      ? `<div class="bet-timer">${formatTime(left)}</div>`
      : `<div class="bet-timer expired">AWAIT</div>`;
    const dc = bet.direction === 'UP' ? 'up' : 'down';
    return `<div class="bet-item">
      <span class="bet-dir-badge ${dc}">${bet.direction}</span>
      <div class="bet-info">
        <div class="bet-amount">${parseFloat(bet.amount).toFixed(4)} ETH</div>
        <div class="bet-meta">Round #${bet.roundId} Â· ${bet.coin} Â· ${bet.durationMin}m</div>
      </div>${timer}</div>`;
  }).join('');
}

function formatTime(s) {
  const m = Math.floor(s/60);
  return m > 0 ? `${m}:${(s%60).toString().padStart(2,'0')}` : `${s}s`;
}

// â”€â”€ Connect â”€â”€
async function connect() {
  if (!window.ethereum) { alert("MetaMask not found!"); return; }
  try {
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    const network = await provider.getNetwork();
    if (network.chainId !== CHAIN_ID) {
      try {
        await window.ethereum.request({ method:'wallet_switchEthereumChain', params:[{chainId:'0x'+CHAIN_ID.toString(16)}] });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      } catch(e) { alert("Switch to Robinhood Chain Testnet (ChainID: 46630)"); return; }
    }
    signer = provider.getSigner();
    user = await signer.getAddress();
    contract = new ethers.Contract(CONTRACT_ADDRESS, abi, signer);
    contractOwner = await contract.owner();
    document.getElementById("wallet").innerText = user.slice(0,6)+"..."+user.slice(-4);
    const btn = document.getElementById("btnConnect");
    btn.innerText = user.slice(0,6)+"..."+user.slice(-4);
    btn.classList.add("connected");
    btn.onclick = null;
    document.getElementById("btnClaim").disabled = false;
    updateBetButtons();
    if (user.toLowerCase() === contractOwner.toLowerCase()) {
      document.getElementById("ownerPanel").style.display = "block";
      await loadOwnerStats();
    }
    await loadData();
    setInterval(loadData, 10000);
  } catch(e) { alert("Connection error: " + e.message); }
}

// â”€â”€ Load data â”€â”€
async function loadData() {
  if (!contract) return;
  try {
    const roundId = await contract.currentRound();
    document.getElementById("round").innerText = "#" + roundId.toString();
    const banner = document.getElementById("resultBanner");
    if (roundId.toNumber() === 0) {
      isRoundActive = false; alreadyBetThisRound = false;
      updateBetButtons(); setStatus("No rounds yet","waiting");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      document.getElementById("lockPrice").innerText = "â€”";
      banner.className = "result-banner"; return;
    }
    const pool = await contract.pools(roundId, ethers.constants.AddressZero);
    const up = parseFloat(ethers.utils.formatEther(pool[0]));
    const down = parseFloat(ethers.utils.formatEther(pool[1]));
    document.getElementById("upPool").innerText = up.toFixed(4);
    document.getElementById("downPool").innerText = down.toFixed(4);
    const total = up + down;
    const prob = total > 0 ? (up/total*100).toFixed(1) : 50;
    document.getElementById("probUp").innerText = prob + "%";
    document.getElementById("poolBar").style.width = prob + "%";
    const round = await contract.rounds(roundId);
    const endTime = round[1].toNumber();
    const lockPriceRaw = round[2].toNumber();
    const settled = round[6];
    document.getElementById("lockPrice").innerText = lockPriceRaw > 0 ? "$"+lockPriceRaw.toLocaleString() : "â€”";
    const now = Math.floor(Date.now()/1000);
    if (settled) {
      isRoundActive = false; alreadyBetThisRound = false;
      const upWon = round[7]; const closePrice = round[3].toNumber();
      setStatus("Settled","waiting");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      if (roundTimerInterval) { clearInterval(roundTimerInterval); roundTimerInterval = null; }
      banner.className = "result-banner show " + (upWon ? "up-won" : "down-won");
      banner.innerHTML = upWon ? `â–² UP WON Â· Close $${closePrice.toLocaleString()}` : `â–¼ DOWN WON Â· Close $${closePrice.toLocaleString()}`;
    } else if (now >= endTime) {
      isRoundActive = false; alreadyBetThisRound = false;
      setStatus("Settling...","ended");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      if (roundTimerInterval) { clearInterval(roundTimerInterval); roundTimerInterval = null; }
      banner.className = "result-banner";
      await autoSettle();
    } else {
      isRoundActive = true; setStatus("Active","active");
      startRoundTimer(endTime); banner.className = "result-banner";
      if (user) {
        const userBet = await contract.pools(roundId, user);
        alreadyBetThisRound = userBet[0].gt(0) || userBet[1].gt(0);
      }
    }
    updateBetButtons(); await loadOwnerStats();
  } catch(e) { console.error("loadData error:", e); }
}

function setStatus(text, type) {
  const el = document.getElementById("roundStatus");
  el.innerText = text; el.className = "status-pill status-" + type;
}

function startRoundTimer(endTime) {
  if (roundTimerInterval) clearInterval(roundTimerInterval);
  roundTimerInterval = setInterval(async () => {
    const left = endTime - Math.floor(Date.now()/1000);
    if (left > 0) {
      document.getElementById("timeLeftSmall").innerText = formatTime(left);
    } else {
      isRoundActive = false; alreadyBetThisRound = false; updateBetButtons();
      setStatus("Settling...","ended");
      document.getElementById("timeLeftSmall").innerText = "â€”";
      clearInterval(roundTimerInterval); roundTimerInterval = null;
      await autoSettle();
    }
  }, 1000);
}

async function autoSettle() {
  if (!contract || !user || !contractOwner) return;
  if (user.toLowerCase() !== contractOwner.toLowerCase()) { setTimeout(loadData, 5000); return; }
  try {
    let closePrice = 0;
    try { closePrice = await fetchCoinPrice(selectedCoin); }
    catch(e) { setTimeout(autoSettle, 5000); return; }
    const tx = await contract.settleRound(closePrice);
    await tx.wait(); await loadData();
  } catch(e) { console.error("Auto-settle failed:", e.reason||e.message); setTimeout(autoSettle, 10000); }
}

// â”€â”€ Price fetching (per coin) â”€â”€
async function fetchCoinPrice(coin) {
  const cfg = COINS[coin];
  const sources = [
    async () => {
      const r = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${cfg.binance}`);
      const d = await r.json();
      return Math.round(parseFloat(d.price));
    },
    async () => {
      const r = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${cfg.cgId}&vs_currencies=usd`);
      const d = await r.json();
      return Math.round(d[cfg.cgId].usd);
    }
  ];
  for (const src of sources) {
    try { const p = await src(); if (p > 0) return p; } catch(e) {}
  }
  throw new Error("All price sources failed");
}

async function fetchBTCPrice() { return fetchCoinPrice(selectedCoin); }

async function autoStartRound() {
  try {
    const lockPrice = await fetchCoinPrice(selectedCoin);
    const tx = await contract.startRound(selectedDuration, lockPrice);
    await tx.wait(); await loadData();
  } catch(e) { alert("Could not start round: " + (e.reason||e.message)); }
}

async function betUp() {
  if (!checkConnected()) return;
  const amount = document.getElementById("amount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter a valid amount"); return; }
  try {
    document.getElementById("btnUp").disabled = true;
    document.getElementById("btnDown").disabled = true;
    if (!isRoundActive) { await autoStartRound(); if (!isRoundActive) return; }
    const roundId = await contract.currentRound();
    const tx = await contract.betUp({ value: ethers.utils.parseEther(amount) });
    await tx.wait(); addActiveBet('UP', amount, selectedDuration, roundId); await loadData();
  } catch(e) { alert("Bet UP failed: " + (e.reason||e.message)); }
  finally { updateBetButtons(); }
}

async function betDown() {
  if (!checkConnected()) return;
  const amount = document.getElementById("amount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter a valid amount"); return; }
  try {
    document.getElementById("btnDown").disabled = true;
    document.getElementById("btnUp").disabled = true;
    if (!isRoundActive) { await autoStartRound(); if (!isRoundActive) return; }
    const roundId = await contract.currentRound();
    const tx = await contract.betDown({ value: ethers.utils.parseEther(amount) });
    await tx.wait(); addActiveBet('DOWN', amount, selectedDuration, roundId); await loadData();
  } catch(e) { alert("Bet DOWN failed: " + (e.reason||e.message)); }
  finally { updateBetButtons(); }
}

async function claim() {
  if (!checkConnected()) return;
  try {
    const roundId = await contract.currentRound();
    const tx = await contract.claim(roundId.sub(1), user);
    await tx.wait();
    activeBets = activeBets.filter(b => b.endTime > Math.floor(Date.now()/1000));
    renderBets(); alert("Claimed!");
  } catch(e) { alert("Claim failed: " + (e.reason||e.message)); }
}

async function loadOwnerStats() {
  if (!contract || !user || user.toLowerCase() !== contractOwner?.toLowerCase()) return;
  try {
    const info = await contract.balanceInfo();
    const fmt = v => parseFloat(ethers.utils.formatEther(v)).toFixed(4) + " ETH";
    document.getElementById("ownerBalContract").innerText  = fmt(info[0]);
    document.getElementById("ownerBalProfit").innerText    = fmt(info[1]);
    document.getElementById("ownerBalLiquidity").innerText = fmt(info[2]);
  } catch(e) {}
}

async function ownerDeposit() {
  const amount = document.getElementById("depositAmount").value;
  if (!amount || parseFloat(amount) <= 0) { alert("Enter ETH amount"); return; }
  try {
    const tx = await contract.depositLiquidity({ value: ethers.utils.parseEther(amount) });
    await tx.wait(); document.getElementById("depositAmount").value = "";
    await loadOwnerStats(); alert("Deposited âœ“");
  } catch(e) { alert("Deposit failed: " + (e.reason||e.message)); }
}

async function ownerWithdraw() {
  const input = document.getElementById("withdrawAmount").value;
  const amount = (!input || parseFloat(input) === 0) ? 0 : ethers.utils.parseEther(input);
  try {
    const tx = await contract.withdrawProfit(amount);
    await tx.wait(); document.getElementById("withdrawAmount").value = "";
    await loadOwnerStats(); alert("Withdrawn âœ“");
  } catch(e) { alert("Withdraw failed: " + (e.reason||e.message)); }
}

async function ownerWithdrawAll() {
  try {
    const tx = await contract.withdrawProfit(0);
    await tx.wait(); await loadOwnerStats(); alert("All profit withdrawn âœ“");
  } catch(e) { alert("Withdraw failed: " + (e.reason||e.message)); }
}

function checkConnected() {
  if (!user || !contract) { alert("Please connect your wallet first"); return false; }
  return true;
}

// Init chart
tvWidget = new TradingView.widget({
  container_id: 'tv_chart',
  symbol: 'BINANCE:BTCUSDT',
  interval: '1',
  theme: 'dark',
  width: '100%',
  height: '100%',
  autosize: true,
  hide_side_toolbar: true,
  allow_symbol_change: false,
});

// Load prices via REST first, then switch to WebSocket for real-time
loadAllPrices();
startPriceWebSocket();

// â”€â”€â”€ Graffiti background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function() {
  const canvas = document.getElementById('graffiti-bg');
  const ctx = canvas.getContext('2d');
  const NEON = '#d5fd51';
  const NEON2 = '#b8e530';
  const WHITE = 'rgba(255,255,255,0.07)';
  const DIM = 'rgba(213,253,81,0.08)';

  function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
  }

  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function rand(min, max) { return Math.random() * (max - min) + min; }

  // Seeded random so it's consistent per session
  let seed = 42;
  function srnd() {
    seed = (seed * 16807 + 0) % 2147483647;
    return (seed - 1) / 2147483646;
  }
  function srandInt(min, max) { return Math.floor(srnd() * (max - min + 1)) + min; }
  function srand(min, max) { return srnd() * (max - min) + min; }

  function drawSprayPaint(ctx, x, y, radius, color, density = 60) {
    ctx.save();
    for (let i = 0; i < density; i++) {
      const angle = srnd() * Math.PI * 2;
      const r = Math.pow(srnd(), 0.5) * radius;
      const px = x + Math.cos(angle) * r;
      const py = y + Math.sin(angle) * r;
      const alpha = srand(0.02, 0.18);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(px, py, srand(0.5, 2.5), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawGraffitiLetter(ctx, x, y, letter, size, color, angle = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);

    // Outline / drip effect
    ctx.font = `900 ${size}px 'Syne', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Spray halo
    drawSprayPaint(ctx, 0, 0, size * 0.7, color, 80);

    // Shadow layers for depth
    ctx.shadowColor = color;
    ctx.shadowBlur = size * 0.3;
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = color;
    ctx.fillText(letter, 3, 6);

    // Outline stroke
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = color;
    ctx.lineWidth = size * 0.08;
    ctx.lineJoin = 'round';
    ctx.strokeText(letter, 0, 0);

    // Fill
    ctx.globalAlpha = 0.09;
    ctx.fillStyle = color;
    ctx.fillText(letter, 0, 0);

    // Drip
    const dripCount = srandInt(1, 3);
    for (let d = 0; d < dripCount; d++) {
      const dx = srand(-size * 0.3, size * 0.3);
      const dripLen = srand(size * 0.2, size * 0.9);
      const dripW = srand(2, 6);
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = color;
      ctx.lineWidth = dripW;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(dx, size * 0.4);
      ctx.bezierCurveTo(
        dx + srand(-8, 8), size * 0.5 + dripLen * 0.3,
        dx + srand(-8, 8), size * 0.5 + dripLen * 0.7,
        dx + srand(-4, 4), size * 0.4 + dripLen
      );
      ctx.stroke();
      // Drip end blob
      ctx.globalAlpha = 0.1;
      ctx.beginPath();
      ctx.arc(dx + srand(-4,4), size * 0.4 + dripLen, dripW * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }

    ctx.restore();
  }

  function drawTag(ctx, x, y, text, size, color, skew = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.transform(1, 0, skew, 1, 0, 0);

    const letters = text.split('');
    let ox = 0;
    for (const l of letters) {
      const angle = srand(-0.15, 0.15);
      const vertJitter = srand(-size * 0.15, size * 0.15);
      drawGraffitiLetter(ctx, ox, vertJitter, l, size, color, angle);
      ox += size * srand(0.55, 0.72);
    }
    ctx.restore();
  }

  function drawLine(ctx, x1, y1, x2, y2, color, width, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.lineCap = 'round';
    ctx.shadowColor = color;
    ctx.shadowBlur = width * 3;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  function drawArrow(ctx, x, y, size, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(srand(-0.3, 0.3));
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = color;
    ctx.lineWidth = size * 0.08;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    // Arrow up
    ctx.moveTo(0, size * 0.5);
    ctx.lineTo(0, -size * 0.5);
    ctx.moveTo(-size * 0.3, -size * 0.2);
    ctx.lineTo(0, -size * 0.5);
    ctx.lineTo(size * 0.3, -size * 0.2);
    ctx.stroke();
    ctx.restore();
  }

  function drawHexagon(ctx, x, y, r, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(srand(0, Math.PI));
    ctx.globalAlpha = srand(0.04, 0.1);
    ctx.strokeStyle = color;
    ctx.lineWidth = srand(1, 4);
    ctx.shadowColor = color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i;
      const px = Math.cos(angle) * r;
      const py = Math.sin(angle) * r;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  function draw() {
    const W = canvas.width;
    const H = canvas.height;
    seed = 42; // reset seed for consistent render

    ctx.clearRect(0, 0, W, H);

    // â”€â”€ Base: deep dark gradient (not pure black) â”€â”€
    const bgGrad = ctx.createLinearGradient(0, 0, W, H);
    bgGrad.addColorStop(0,   '#0d1a0a');
    bgGrad.addColorStop(0.3, '#0a0f1a');
    bgGrad.addColorStop(0.6, '#130d1f');
    bgGrad.addColorStop(1,   '#0a1410');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // â”€â”€ Ink splat blobs â€” big color explosions â”€â”€
    const blobs = [
      { x: W*0.08,  y: H*0.15, r: W*0.22, c: 'rgba(213,253,81,',  a: 0.13 },
      { x: W*0.85,  y: H*0.75, r: W*0.28, c: 'rgba(213,253,81,',  a: 0.10 },
      { x: W*0.5,   y: H*0.5,  r: W*0.35, c: 'rgba(74,222,128,',  a: 0.07 },
      { x: W*0.9,   y: H*0.1,  r: W*0.18, c: 'rgba(248,113,113,', a: 0.10 },
      { x: W*0.1,   y: H*0.85, r: W*0.20, c: 'rgba(248,113,113,', a: 0.08 },
      { x: W*0.55,  y: H*0.2,  r: W*0.15, c: 'rgba(184,229,48,',  a: 0.09 },
      { x: W*0.25,  y: H*0.55, r: W*0.12, c: 'rgba(213,253,81,',  a: 0.08 },
      { x: W*0.75,  y: H*0.45, r: W*0.16, c: 'rgba(74,222,128,',  a: 0.08 },
    ];

    for (const b of blobs) {
      // Radial splat
      const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
      g.addColorStop(0,   b.c + (b.a * 2.5) + ')');
      g.addColorStop(0.4, b.c + b.a + ')');
      g.addColorStop(0.75, b.c + (b.a * 0.3) + ')');
      g.addColorStop(1,   b.c + '0)');
      ctx.globalAlpha = 1;
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();

      // Splatter droplets around blob
      const color = b.c + (b.a * 3) + ')';
      for (let s = 0; s < 18; s++) {
        const angle = srnd() * Math.PI * 2;
        const dist  = srand(b.r * 0.5, b.r * 1.6);
        const sx = b.x + Math.cos(angle) * dist;
        const sy = b.y + Math.sin(angle) * dist;
        const sr2 = srand(2, b.r * 0.12);
        ctx.globalAlpha = srand(0.05, 0.18);
        ctx.fillStyle = b.c + (b.a * 4) + ')';
        ctx.beginPath();
        // Elongated splat drop
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(angle + Math.PI/2);
        ctx.ellipse(0, 0, sr2 * 0.5, sr2, 0, 0, Math.PI * 2);
        ctx.restore();
        ctx.fill();
      }
    }

    // â”€â”€ Spray strokes â€” wide brush marks â”€â”€
    const strokes = [
      { x1: W*0.0,  y1: H*0.3,  x2: W*0.4,  y2: H*0.15, c: NEON,            w: 80 },
      { x1: W*0.6,  y1: H*0.85, x2: W*1.0,  y2: H*0.65, c: NEON2,           w: 60 },
      { x1: W*0.2,  y1: H*0.9,  x2: W*0.7,  y2: H*0.95, c: '#4ade80',       w: 50 },
      { x1: W*0.7,  y1: H*0.0,  x2: W*0.95, y2: H*0.35, c: '#f87171',       w: 55 },
      { x1: W*0.0,  y1: H*0.65, x2: W*0.25, y2: H*0.5,  c: NEON,            w: 40 },
    ];

    for (const s of strokes) {
      const sg = ctx.createLinearGradient(s.x1, s.y1, s.x2, s.y2);
      sg.addColorStop(0,   s.c + '00');
      sg.addColorStop(0.3, s.c + '22');
      sg.addColorStop(0.5, s.c + '18');
      sg.addColorStop(1,   s.c + '00');
      ctx.globalAlpha = 1;
      ctx.strokeStyle = sg;
      ctx.lineWidth = s.w;
      ctx.lineCap = 'round';
      ctx.shadowColor = s.c;
      ctx.shadowBlur = s.w * 0.8;
      ctx.beginPath();
      ctx.moveTo(s.x1, s.y1);
      const mx = (s.x1 + s.x2) / 2 + srand(-W*0.1, W*0.1);
      const my = (s.y1 + s.y2) / 2 + srand(-H*0.1, H*0.1);
      ctx.quadraticCurveTo(mx, my, s.x2, s.y2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // â”€â”€ Concrete texture: noise â”€â”€
    for (let i = 0; i < 4000; i++) {
      ctx.globalAlpha = srand(0.01, 0.05);
      ctx.fillStyle = srnd() > 0.6 ? '#ffffff' : (srnd() > 0.5 ? NEON : '#333');
      const px = srnd() * W, py = srnd() * H;
      ctx.fillRect(px, py, srand(0.5, 2), srand(0.5, 2));
    }

    // Big background tags - words scattered
    const words = ['BLOCKORACLE', 'UP', 'DOWN', 'BTC', 'PREDICT', 'WIN', 'CHAIN', '0x'];
    const colors = [NEON, NEON2, 'rgba(255,255,255,0.6)', NEON];

    // Large background word
    drawTag(ctx, W * 0.02, H * 0.18, 'BLOCKORACLE', Math.min(W * 0.075, 90), NEON, -0.05);
    drawTag(ctx, W * 0.55, H * 0.72, 'ROBINHOOD', Math.min(W * 0.065, 80), NEON2, 0.04);
    drawTag(ctx, W * 0.05, H * 0.82, 'BTC', Math.min(W * 0.1, 120), NEON, -0.08);
    drawTag(ctx, W * 0.6, H * 0.12, 'PREDICT', Math.min(W * 0.055, 70), 'rgba(255,255,255,0.5)', 0.06);
    drawTag(ctx, W * 0.3, H * 0.45, 'WIN', Math.min(W * 0.12, 140), NEON2, -0.03);
    drawTag(ctx, W * 0.7, H * 0.38, '0xCHAIN', Math.min(W * 0.045, 55), NEON, 0.03);
    drawTag(ctx, W * 0.15, H * 0.6, 'UP', Math.min(W * 0.09, 110), NEON, 0.05);
    drawTag(ctx, W * 0.75, H * 0.6, 'DOWN', Math.min(W * 0.07, 85), '#f87171', -0.04);

    // Hexagons (blockchain motif)
    for (let i = 0; i < 18; i++) {
      drawHexagon(ctx, srnd() * W, srnd() * H, srand(20, 90), i % 3 === 0 ? NEON : NEON2);
    }

    // Arrows (UP / DOWN arrows)
    for (let i = 0; i < 12; i++) {
      drawArrow(ctx, srnd() * W, srnd() * H, srand(30, 80), srnd() > 0.5 ? NEON : '#f87171');
    }

    // Scratchy tag lines
    for (let i = 0; i < 25; i++) {
      const x1 = srnd() * W, y1 = srnd() * H;
      const x2 = x1 + srand(-200, 200), y2 = y1 + srand(-80, 80);
      drawLine(ctx, x1, y1, x2, y2, srnd() > 0.7 ? NEON : 'rgba(255,255,255,0.3)', srand(0.5, 3), srand(0.02, 0.07));
    }

    // Spray circles (random spots)
    for (let i = 0; i < 20; i++) {
      drawSprayPaint(ctx, srnd() * W, srnd() * H, srand(30, 120), srnd() > 0.5 ? NEON : NEON2, 40);
    }

    // Semi-transparent dark overlay so UI stays readable
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = '#080808';
    ctx.fillRect(0, 0, W, H);

    // Vignette edges
    const vignette = ctx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H);
    vignette.addColorStop(0,   'rgba(0,0,0,0)');
    vignette.addColorStop(0.7, 'rgba(0,0,0,0.2)');
    vignette.addColorStop(1,   'rgba(0,0,0,0.75)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, W, H);
  }

  window.addEventListener('resize', resize);
  // Wait for Syne font to load for text rendering
  document.fonts.ready.then(resize);
  resize();
})();


</script>
</body>
</html>
